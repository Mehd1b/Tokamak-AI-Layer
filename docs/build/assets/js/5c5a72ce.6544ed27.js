"use strict";(globalThis.webpackChunktal_docs=globalThis.webpackChunktal_docs||[]).push([[5954],{5421(e,n,s){s.r(n),s.d(n,{assets:()=>o,contentTitle:()=>d,default:()=>h,frontMatter:()=>a,metadata:()=>r,toc:()=>l});const r=JSON.parse('{"id":"architecture/cross-layer-bridge","title":"Cross-Layer Bridge","description":"The TAL cross-layer bridge connects Ethereum L1 staking infrastructure with Tokamak L2 registry contracts. It enables L2 contracts to make trust decisions based on L1 economic security without requiring L2 users to pay L1 gas costs for every stake lookup. The bridge consists of three contracts: TALStakingBridgeL1 on Ethereum, TALStakingBridgeL2 on Tokamak L2, and TALSlashingConditionsL1 for slash execution on L1.","source":"@site/docs/architecture/cross-layer-bridge.md","sourceDirName":"architecture","slug":"/architecture/cross-layer-bridge","permalink":"/architecture/cross-layer-bridge","draft":false,"unlisted":false,"editUrl":"https://github.com/tokamak-network/Tokamak-AI-Layer/tree/master/docs/docs/architecture/cross-layer-bridge.md","tags":[],"version":"current","sidebarPosition":3,"frontMatter":{"title":"Cross-Layer Bridge","sidebar_position":3},"sidebar":"docsSidebar","previous":{"title":"Trust Model","permalink":"/architecture/trust-model"},"next":{"title":"Identity Registry","permalink":"/contracts/identity-registry"}}');var i=s(4848),t=s(8453);const a={title:"Cross-Layer Bridge",sidebar_position:3},d="Cross-Layer Bridge",o={},l=[{value:"L1/L2 Architecture Overview",id:"l1l2-architecture-overview",level:2},{value:"CrossDomainMessenger Flow",id:"crossdomainmessenger-flow",level:2},{value:"Authentication",id:"authentication",level:3},{value:"Stake Relay: L1 to L2",id:"stake-relay-l1-to-l2",level:2},{value:"StakeSnapshot Structure",id:"stakesnapshot-structure",level:3},{value:"Cache Freshness",id:"cache-freshness",level:3},{value:"Batch and Keeper Operations",id:"batch-and-keeper-operations",level:3},{value:"Slashing Propagation: L2 to L1",id:"slashing-propagation-l2-to-l1",level:2},{value:"Slash Request Structure",id:"slash-request-structure",level:3},{value:"Slash Execution on L1",id:"slash-execution-on-l1",level:3},{value:"Operator Tiers",id:"operator-tiers",level:2},{value:"Tier Constants",id:"tier-constants",level:3},{value:"L1 Contract Dependencies",id:"l1-contract-dependencies",level:2},{value:"Seigniorage Flow",id:"seigniorage-flow",level:3},{value:"Bridge Configuration",id:"bridge-configuration",level:2},{value:"TALStakingBridgeL1 Initialization",id:"talstakingbridgel1-initialization",level:3},{value:"TALStakingBridgeL2 Initialization",id:"talstakingbridgel2-initialization",level:3},{value:"TALSlashingConditionsL1 Initialization",id:"talslashingconditionsl1-initialization",level:3},{value:"Access Control Summary",id:"access-control-summary",level:2},{value:"Next Steps",id:"next-steps",level:2}];function c(e){const n={a:"a",admonition:"admonition",code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",li:"li",mermaid:"mermaid",p:"p",pre:"pre",strong:"strong",table:"table",tbody:"tbody",td:"td",th:"th",thead:"thead",tr:"tr",ul:"ul",...(0,t.R)(),...e.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(n.header,{children:(0,i.jsx)(n.h1,{id:"cross-layer-bridge",children:"Cross-Layer Bridge"})}),"\n",(0,i.jsxs)(n.p,{children:["The TAL cross-layer bridge connects Ethereum L1 staking infrastructure with Tokamak L2 registry contracts. It enables L2 contracts to make trust decisions based on L1 economic security without requiring L2 users to pay L1 gas costs for every stake lookup. The bridge consists of three contracts: ",(0,i.jsx)(n.code,{children:"TALStakingBridgeL1"})," on Ethereum, ",(0,i.jsx)(n.code,{children:"TALStakingBridgeL2"})," on Tokamak L2, and ",(0,i.jsx)(n.code,{children:"TALSlashingConditionsL1"})," for slash execution on L1."]}),"\n",(0,i.jsx)(n.h2,{id:"l1l2-architecture-overview",children:"L1/L2 Architecture Overview"}),"\n",(0,i.jsx)(n.mermaid,{value:'flowchart TB\n    subgraph L1["Ethereum L1"]\n        SV2[SeigManager<br/>Staking V3]\n        DM[DepositManager]\n        SBL1[TALStakingBridgeL1]\n        SC[TALSlashingConditionsL1]\n        CDM1[L1CrossDomainMessenger]\n    end\n\n    subgraph L2["Tokamak L2"]\n        SBL2[TALStakingBridgeL2]\n        CDM2[L2CrossDomainMessenger]\n        IR[TALIdentityRegistry]\n        RR[TALReputationRegistry]\n        VR[TALValidationRegistry]\n        SIM[StakingIntegrationModule]\n    end\n\n    SBL1 --\x3e|stakeOf query| SV2\n    SC --\x3e|stakeOf query| SV2\n    SC --\x3e|slash execution| DM\n\n    SBL1 <--\x3e|Cross-layer messages| CDM1\n    CDM1 <--\x3e|Optimism Bridge| CDM2\n    CDM2 <--\x3e|Cross-layer messages| SBL2\n\n    SBL2 --\x3e|isVerifiedOperator / getOperatorStake| IR\n    SBL2 --\x3e|stake-weighted calculations| RR\n    SBL2 --\x3e|stake verification| VR\n    SBL2 --\x3e|stake queries| SIM\n\n    SBL1 --\x3e|slashing delegation| SC'}),"\n",(0,i.jsx)(n.h2,{id:"crossdomainmessenger-flow",children:"CrossDomainMessenger Flow"}),"\n",(0,i.jsxs)(n.p,{children:["All cross-layer communication uses Optimism's native ",(0,i.jsx)(n.code,{children:"CrossDomainMessenger"})," contracts. Messages sent from L1 to L2 are processed after Optimism includes the L1 transaction in an L2 block. Messages from L2 to L1 require the standard 7-day finalization period before they can be executed on L1."]}),"\n",(0,i.jsx)(n.h3,{id:"authentication",children:"Authentication"}),"\n",(0,i.jsx)(n.p,{children:"Both bridge contracts enforce strict sender verification:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-solidity",children:"// TALStakingBridgeL2 -- only accepts messages from L1 bridge\nmodifier onlyFromL1Bridge() {\n    if (msg.sender != l2CrossDomainMessenger) revert UnauthorizedBridgeCaller();\n    // In production, also verify:\n    // ICrossDomainMessenger(l2CrossDomainMessenger).xDomainMessageSender() == l1BridgeAddress\n    _;\n}\n\n// TALStakingBridgeL1 -- only accepts messages from L2 bridge\nmodifier onlyFromL2Bridge() {\n    if (msg.sender != l1CrossDomainMessenger) revert UnauthorizedBridgeCaller();\n    // In production, also verify:\n    // ICrossDomainMessenger(l1CrossDomainMessenger).xDomainMessageSender() == l2BridgeAddress\n    _;\n}\n"})}),"\n",(0,i.jsx)(n.p,{children:"This two-layer check ensures that only the legitimate counterpart bridge can trigger state changes through the messenger."}),"\n",(0,i.jsx)(n.h2,{id:"stake-relay-l1-to-l2",children:"Stake Relay: L1 to L2"}),"\n",(0,i.jsx)(n.p,{children:"The primary bridge function relays operator stake snapshots from L1 to L2, enabling L2 contracts to make stake-based trust decisions without cross-chain calls."}),"\n",(0,i.jsx)(n.mermaid,{value:"sequenceDiagram\n    participant Keeper as Keeper / Anyone\n    participant SBL1 as TALStakingBridgeL1<br/>(Ethereum L1)\n    participant SM as SeigManager<br/>(Staking V3)\n    participant CDM as CrossDomainMessenger\n    participant SBL2 as TALStakingBridgeL2<br/>(Tokamak L2)\n\n    Keeper->>SBL1: queryAndRelayStake(operator)\n    SBL1->>SM: stakeOf(talLayer2Address, operator)\n    SM--\x3e>SBL1: stakeAmount (includes seigniorage)\n    SBL1->>CDM: sendMessage(l2Bridge, receiveStakeUpdate(...))\n    Note over CDM: Message relayed L1 \u2192 L2\n    CDM->>SBL2: receiveStakeUpdate(operator, amount, l1Block)\n    SBL2--\x3e>SBL2: Cache StakeSnapshot\n    SBL2--\x3e>SBL2: Calculate and update OperatorTier\n    Note over SBL2: Emit StakeUpdated + OperatorTierChanged"}),"\n",(0,i.jsx)(n.h3,{id:"stakesnapshot-structure",children:"StakeSnapshot Structure"}),"\n",(0,i.jsx)(n.p,{children:"Each operator's stake is cached as a snapshot with provenance metadata:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-solidity",children:"struct StakeSnapshot {\n    uint256 amount;            // Staked TON on L1 (includes seigniorage)\n    uint256 lastUpdatedL1Block; // L1 block number at query time\n    uint256 timestamp;          // L2 block.timestamp when snapshot was received\n}\n"})}),"\n",(0,i.jsx)(n.h3,{id:"cache-freshness",children:"Cache Freshness"}),"\n",(0,i.jsx)(n.p,{children:"L2 contracts can check whether a cached snapshot is still valid:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-solidity",children:"function isCacheFresh(address operator, uint256 maxAge) external view returns (bool) {\n    if (operatorStakes[operator].timestamp == 0) return false;\n    return (block.timestamp - operatorStakes[operator].timestamp) <= maxAge;\n}\n"})}),"\n",(0,i.jsxs)(n.p,{children:["The default maximum cache age is 4 hours (",(0,i.jsx)(n.code,{children:"DEFAULT_MAX_CACHE_AGE"}),")."]}),"\n",(0,i.jsx)(n.h3,{id:"batch-and-keeper-operations",children:"Batch and Keeper Operations"}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.code,{children:"TALStakingBridgeL1"})," supports multiple stake relay patterns:"]}),"\n",(0,i.jsxs)(n.table,{children:[(0,i.jsx)(n.thead,{children:(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.th,{children:"Function"}),(0,i.jsx)(n.th,{children:"Caller"}),(0,i.jsx)(n.th,{children:"Description"})]})}),(0,i.jsxs)(n.tbody,{children:[(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:(0,i.jsx)(n.code,{children:"queryAndRelayStake(operator)"})}),(0,i.jsx)(n.td,{children:"Anyone"}),(0,i.jsx)(n.td,{children:"Relay a single operator's stake"})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:(0,i.jsx)(n.code,{children:"batchQueryStakes(operators[])"})}),(0,i.jsx)(n.td,{children:"Anyone"}),(0,i.jsx)(n.td,{children:"Relay up to 100 operators in one transaction"})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:(0,i.jsx)(n.code,{children:"refreshAllOperators()"})}),(0,i.jsx)(n.td,{children:(0,i.jsx)(n.code,{children:"KEEPER_ROLE"})}),(0,i.jsx)(n.td,{children:"Relay all registered TAL operators (up to 100)"})]})]})]}),"\n",(0,i.jsx)(n.admonition,{title:"Where in the code?",type:"tip",children:(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"TALStakingBridgeL1"}),": ",(0,i.jsx)(n.code,{children:"contracts/src/bridge/TALStakingBridgeL1.sol"})," (307 lines)"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"TALStakingBridgeL2"}),": ",(0,i.jsx)(n.code,{children:"contracts/src/bridge/TALStakingBridgeL2.sol"})," (286 lines)"]}),"\n"]})}),"\n",(0,i.jsx)(n.h2,{id:"slashing-propagation-l2-to-l1",children:"Slashing Propagation: L2 to L1"}),"\n",(0,i.jsx)(n.p,{children:"When misbehavior is detected on L2 (e.g., a dispute is upheld against a validator), the slashing flow propagates from L2 to L1:"}),"\n",(0,i.jsx)(n.mermaid,{value:"sequenceDiagram\n    participant VR as TALValidationRegistry<br/>(L2)\n    participant SBL2 as TALStakingBridgeL2<br/>(L2)\n    participant CDM as CrossDomainMessenger\n    participant SBL1 as TALStakingBridgeL1<br/>(L1)\n    participant SC as TALSlashingConditionsL1<br/>(L1)\n    participant DM as DepositManager<br/>(L1)\n\n    VR->>SBL2: requestSlashing(operator, amount, evidence)\n    Note over SBL2: Create SlashRequest with evidenceHash\n    SBL2->>CDM: sendMessage(l1Bridge, executeSlashing(...))\n\n    Note over CDM: \u23f3 7-day Optimism finalization period<br/>(natural appeal window)\n\n    CDM->>SBL1: executeSlashing(operator, amount, evidence)\n    SBL1->>SC: slash(operator, amount)\n    SC->>SC: Verify stake >= amount\n    SC->>DM: slash(talLayer2Address, slashRecipient, amount)\n    DM--\x3e>SC: success\n    Note over SC: Update totalSlashedAmount, slashCount\n\n    SBL1->>SBL1: _queryStake(operator) -- refresh after slash\n    SBL1->>CDM: sendMessage(l2Bridge, receiveStakeUpdate(...))\n    Note over CDM: Relay updated stake to L2\n    CDM->>SBL2: receiveStakeUpdate(operator, newAmount, l1Block)"}),"\n",(0,i.jsx)(n.h3,{id:"slash-request-structure",children:"Slash Request Structure"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-solidity",children:"struct SlashRequest {\n    address operator;      // Operator being slashed\n    uint256 amount;        // Amount to slash\n    bytes32 evidenceHash;  // keccak256 of evidence bytes\n    uint256 timestamp;     // When the request was created on L2\n    bool executed;         // Whether the slash has been executed on L1\n}\n"})}),"\n",(0,i.jsx)(n.h3,{id:"slash-execution-on-l1",children:"Slash Execution on L1"}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.code,{children:"TALSlashingConditionsL1"})," executes slashes against Staking V3's ",(0,i.jsx)(n.code,{children:"DepositManager"}),":"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-solidity",children:"// Slash via Staking V3 DepositManager\nbool success = IDepositManagerV3(depositManager).slash(\n    talLayer2Address,   // Layer2 contract address\n    slashRecipient,     // Treasury receives slashed funds\n    amount              // Amount to slash\n);\n"})}),"\n",(0,i.jsxs)(n.p,{children:["After slashing, ",(0,i.jsx)(n.code,{children:"TALStakingBridgeL1"})," automatically refreshes the operator's stake on L2 so the cache reflects the reduced balance."]}),"\n",(0,i.jsx)(n.admonition,{type:"danger",children:(0,i.jsx)(n.p,{children:"Once a slash message passes the 7-day finalization window and is executed on L1, the slashed funds are transferred to the treasury and cannot be recovered. There is no restore mechanism in Staking V3."})}),"\n",(0,i.jsx)(n.h2,{id:"operator-tiers",children:"Operator Tiers"}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.code,{children:"TALStakingBridgeL2"})," automatically classifies operators into three tiers based on their cached L1 stake:"]}),"\n",(0,i.jsxs)(n.table,{children:[(0,i.jsx)(n.thead,{children:(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.th,{children:"Tier"}),(0,i.jsx)(n.th,{children:"Enum"}),(0,i.jsx)(n.th,{children:"Stake Threshold"}),(0,i.jsx)(n.th,{children:"Capabilities"})]})}),(0,i.jsxs)(n.tbody,{children:[(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:(0,i.jsx)(n.strong,{children:"Unverified"})}),(0,i.jsx)(n.td,{children:(0,i.jsx)(n.code,{children:"UNVERIFIED"})}),(0,i.jsx)(n.td,{children:"0 TON"}),(0,i.jsx)(n.td,{children:"Can register agents. Cannot serve as validators for StakeSecured/Hybrid models."})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:(0,i.jsx)(n.strong,{children:"Verified"})}),(0,i.jsx)(n.td,{children:(0,i.jsx)(n.code,{children:"VERIFIED"})}),(0,i.jsx)(n.td,{children:">= 1,000 TON"}),(0,i.jsx)(n.td,{children:"Can serve as validators. Eligible for StakeSecured validation. Sufficient for operator verification in TALIdentityRegistry."})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:(0,i.jsx)(n.strong,{children:"Premium"})}),(0,i.jsx)(n.td,{children:(0,i.jsx)(n.code,{children:"PREMIUM"})}),(0,i.jsx)(n.td,{children:">= 10,000 TON"}),(0,i.jsx)(n.td,{children:"All Verified capabilities. Priority in batch operations. Higher trust signal for reputation weighting."})]})]})]}),"\n",(0,i.jsxs)(n.p,{children:["Tier transitions are automatic and emit an ",(0,i.jsx)(n.code,{children:"OperatorTierChanged"})," event:"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-solidity",children:"function _calculateTier(uint256 amount) internal pure returns (OperatorTier) {\n    if (amount >= PREMIUM_THRESHOLD) return OperatorTier.PREMIUM;   // >= 10,000 TON\n    if (amount >= VERIFIED_THRESHOLD) return OperatorTier.VERIFIED; // >= 1,000 TON\n    return OperatorTier.UNVERIFIED;\n}\n"})}),"\n",(0,i.jsx)(n.h3,{id:"tier-constants",children:"Tier Constants"}),"\n",(0,i.jsxs)(n.table,{children:[(0,i.jsx)(n.thead,{children:(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.th,{children:"Constant"}),(0,i.jsx)(n.th,{children:"Value"}),(0,i.jsx)(n.th,{children:"Description"})]})}),(0,i.jsxs)(n.tbody,{children:[(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:(0,i.jsx)(n.code,{children:"VERIFIED_THRESHOLD"})}),(0,i.jsx)(n.td,{children:(0,i.jsx)(n.code,{children:"1,000 ether"})}),(0,i.jsx)(n.td,{children:"Minimum stake for Verified tier"})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:(0,i.jsx)(n.code,{children:"PREMIUM_THRESHOLD"})}),(0,i.jsx)(n.td,{children:(0,i.jsx)(n.code,{children:"10,000 ether"})}),(0,i.jsx)(n.td,{children:"Minimum stake for Premium tier"})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:(0,i.jsx)(n.code,{children:"DEFAULT_MAX_CACHE_AGE"})}),(0,i.jsx)(n.td,{children:(0,i.jsx)(n.code,{children:"4 hours"})}),(0,i.jsx)(n.td,{children:"Default cache freshness window"})]})]})]}),"\n",(0,i.jsx)(n.h2,{id:"l1-contract-dependencies",children:"L1 Contract Dependencies"}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.code,{children:"TALStakingBridgeL1"})," and ",(0,i.jsx)(n.code,{children:"TALSlashingConditionsL1"})," integrate with Tokamak's existing Staking V3 infrastructure on Ethereum L1:"]}),"\n",(0,i.jsxs)(n.table,{children:[(0,i.jsx)(n.thead,{children:(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.th,{children:"Dependency"}),(0,i.jsx)(n.th,{children:"Interface"}),(0,i.jsx)(n.th,{children:"Used For"})]})}),(0,i.jsxs)(n.tbody,{children:[(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:(0,i.jsx)(n.strong,{children:"SeigManager"})}),(0,i.jsx)(n.td,{children:(0,i.jsx)(n.code,{children:"IStakingV3"})}),(0,i.jsxs)(n.td,{children:[(0,i.jsx)(n.code,{children:"stakeOf(layer2, operator)"})," -- query operator stake; ",(0,i.jsx)(n.code,{children:"updateSeigniorageLayer(layer2)"})," -- trigger seigniorage distribution"]})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:(0,i.jsx)(n.strong,{children:"DepositManager"})}),(0,i.jsx)(n.td,{children:(0,i.jsx)(n.code,{children:"IDepositManagerV3"})}),(0,i.jsxs)(n.td,{children:[(0,i.jsx)(n.code,{children:"slash(layer2, recipient, amount)"})," -- execute slashing, transferring funds to treasury"]})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:(0,i.jsx)(n.strong,{children:"L1CrossDomainMessenger"})}),(0,i.jsx)(n.td,{children:"Optimism standard"}),(0,i.jsxs)(n.td,{children:[(0,i.jsx)(n.code,{children:"sendMessage(target, data, gasLimit)"})," -- relay messages to L2"]})]})]})]}),"\n",(0,i.jsx)(n.h3,{id:"seigniorage-flow",children:"Seigniorage Flow"}),"\n",(0,i.jsxs)(n.p,{children:["Seigniorage (staking rewards) in Staking V3 accrues automatically via coinage tokens. The ",(0,i.jsx)(n.code,{children:"stakeOf()"})," return value includes seigniorage growth, so refreshing the stake snapshot on L2 implicitly captures seigniorage accrual:"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-solidity",children:"function claimAndBridgeSeigniorage(address operator) external whenNotPaused {\n    // Trigger seigniorage update\n    IStakingV3(seigManager).updateSeigniorageLayer(talLayer2Address);\n\n    // Query updated stake (now includes latest seigniorage)\n    uint256 currentStake = _queryStake(operator);\n\n    // Relay to L2\n    _relayStakeToL2(operator, currentStake);\n}\n"})}),"\n",(0,i.jsx)(n.h2,{id:"bridge-configuration",children:"Bridge Configuration"}),"\n",(0,i.jsx)(n.h3,{id:"talstakingbridgel1-initialization",children:"TALStakingBridgeL1 Initialization"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-solidity",children:"function initialize(\n    address admin_,\n    address l1CrossDomainMessenger_,\n    address l2BridgeAddress_,\n    address seigManager_,\n    address slashingConditions_,\n    address talLayer2Address_\n) external initializer;\n"})}),"\n",(0,i.jsx)(n.h3,{id:"talstakingbridgel2-initialization",children:"TALStakingBridgeL2 Initialization"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-solidity",children:"function initialize(\n    address admin_,\n    address l2CrossDomainMessenger_,\n    address l1BridgeAddress_\n) external initializer;\n"})}),"\n",(0,i.jsx)(n.h3,{id:"talslashingconditionsl1-initialization",children:"TALSlashingConditionsL1 Initialization"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-solidity",children:"function initialize(\n    address admin_,\n    address seigManager_,\n    address talLayer2Address_,\n    address bridgeL1_,           // Granted SLASHER_ROLE\n    address depositManager_,\n    address slashRecipient_      // Treasury address\n) external initializer;\n"})}),"\n",(0,i.jsxs)(n.admonition,{title:"Bridge Latency and Finality",type:"warning",children:[(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"L1 to L2"})," messages are included in the next L2 block that processes the L1 transaction, typically within minutes. However, stake data may be stale by the time it arrives on L2."]}),(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"L2 to L1"})," messages require the full Optimism finalization period (currently 7 days) before they can be executed on L1. This means slashing requests created on L2 will not execute on L1 for at least 7 days. This delay is by design -- it serves as an appeal window during which disputed slashes can be reviewed."]}),(0,i.jsxs)(n.p,{children:["Applications relying on real-time stake data should call ",(0,i.jsx)(n.code,{children:"isCacheFresh()"})," and trigger a ",(0,i.jsx)(n.code,{children:"requestStakeRefresh()"})," if the cache is older than ",(0,i.jsx)(n.code,{children:"DEFAULT_MAX_CACHE_AGE"})," (4 hours). Critical operations should not proceed with stale cache data."]})]}),"\n",(0,i.jsx)(n.h2,{id:"access-control-summary",children:"Access Control Summary"}),"\n",(0,i.jsxs)(n.table,{children:[(0,i.jsx)(n.thead,{children:(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.th,{children:"Contract"}),(0,i.jsx)(n.th,{children:"Role"}),(0,i.jsx)(n.th,{children:"Holder"}),(0,i.jsx)(n.th,{children:"Purpose"})]})}),(0,i.jsxs)(n.tbody,{children:[(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:"TALStakingBridgeL1"}),(0,i.jsx)(n.td,{children:(0,i.jsx)(n.code,{children:"KEEPER_ROLE"})}),(0,i.jsx)(n.td,{children:"Automated keeper"}),(0,i.jsxs)(n.td,{children:[(0,i.jsx)(n.code,{children:"refreshAllOperators()"})," batch refresh"]})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:"TALStakingBridgeL1"}),(0,i.jsx)(n.td,{children:(0,i.jsx)(n.code,{children:"DEFAULT_ADMIN_ROLE"})}),(0,i.jsx)(n.td,{children:"Admin multisig"}),(0,i.jsx)(n.td,{children:"Register/remove operators, set SeigManager"})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:"TALStakingBridgeL2"}),(0,i.jsx)(n.td,{children:(0,i.jsx)(n.code,{children:"VALIDATION_REGISTRY_ROLE"})}),(0,i.jsx)(n.td,{children:"TALValidationRegistry"}),(0,i.jsxs)(n.td,{children:[(0,i.jsx)(n.code,{children:"requestSlashing()"})," -- only the registry can initiate slashes"]})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:"TALSlashingConditionsL1"}),(0,i.jsx)(n.td,{children:(0,i.jsx)(n.code,{children:"SLASHER_ROLE"})}),(0,i.jsx)(n.td,{children:"TALStakingBridgeL1"}),(0,i.jsxs)(n.td,{children:[(0,i.jsx)(n.code,{children:"slash()"})," -- only the bridge can execute slashes"]})]})]})]}),"\n",(0,i.jsx)(n.h2,{id:"next-steps",children:"Next Steps"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.a,{href:"/architecture/overview",children:"Architecture Overview"})," -- system-wide contract dependency graph"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.a,{href:"/architecture/trust-model",children:"Trust Model"})," -- slashing conditions, bounty distribution, dispute mechanism"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.a,{href:"/integration/staking-bridge",children:"Staking Integration"})," -- higher-level staking queries and seigniorage routing"]}),"\n"]})]})}function h(e={}){const{wrapper:n}={...(0,t.R)(),...e.components};return n?(0,i.jsx)(n,{...e,children:(0,i.jsx)(c,{...e})}):c(e)}},8453(e,n,s){s.d(n,{R:()=>a,x:()=>d});var r=s(6540);const i={},t=r.createContext(i);function a(e){const n=r.useContext(t);return r.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function d(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(i):e.components||i:a(e.components),r.createElement(t.Provider,{value:n},e.children)}}}]);