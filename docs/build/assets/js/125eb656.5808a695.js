"use strict";(globalThis.webpackChunktal_docs=globalThis.webpackChunktal_docs||[]).push([[3337],{3828(e,n,s){s.r(n),s.d(n,{assets:()=>c,contentTitle:()=>a,default:()=>h,frontMatter:()=>d,metadata:()=>t,toc:()=>l});const t=JSON.parse('{"id":"contracts/task-fee-escrow","title":"Task Fee Escrow","description":"The TaskFeeEscrow is the payment escrow contract for AI agent task execution on the Tokamak AI Layer. Unlike the core registry contracts, it is non-upgradeable and uses native TON (the gas token on Thanos L2) for all payments.","source":"@site/docs/contracts/task-fee-escrow.md","sourceDirName":"contracts","slug":"/contracts/task-fee-escrow","permalink":"/contracts/task-fee-escrow","draft":false,"unlisted":false,"editUrl":"https://github.com/tokamak-network/Tokamak-AI-Layer/tree/master/docs/docs/contracts/task-fee-escrow.md","tags":[],"version":"current","sidebarPosition":4,"frontMatter":{"title":"Task Fee Escrow","sidebar_position":4},"sidebar":"docsSidebar","previous":{"title":"WSTON Vault","permalink":"/contracts/wston-vault"},"next":{"title":"Deployment & Security","permalink":"/contracts/deployment-and-security"}}');var r=s(4848),i=s(8453);const d={title:"Task Fee Escrow",sidebar_position:4},a="Task Fee Escrow",c={},l=[{value:"Overview",id:"overview",level:2},{value:"Key Features",id:"key-features",level:3},{value:"Payment Lifecycle",id:"payment-lifecycle",level:2},{value:"Function Reference",id:"function-reference",level:2},{value:"Agent Owner Functions",id:"agent-owner-functions",level:3},{value:"User Functions",id:"user-functions",level:3},{value:"Escrow Management",id:"escrow-management",level:3},{value:"View Functions",id:"view-functions",level:3},{value:"Events",id:"events",level:2},{value:"Data Structures",id:"data-structures",level:2},{value:"TaskStatus Enum",id:"taskstatus-enum",level:3},{value:"TaskEscrow Struct",id:"taskescrow-struct",level:3},{value:"Constants",id:"constants",level:2},{value:"IIdentityRegistryMinimal Interface",id:"iidentityregistryminimal-interface",level:2},{value:"Code Example: Full Payment Flow",id:"code-example-full-payment-flow",level:2},{value:"Security Considerations",id:"security-considerations",level:2},{value:"Related Pages",id:"related-pages",level:2}];function o(e){const n={a:"a",admonition:"admonition",code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",li:"li",mermaid:"mermaid",p:"p",pre:"pre",strong:"strong",table:"table",tbody:"tbody",td:"td",th:"th",thead:"thead",tr:"tr",ul:"ul",...(0,i.R)(),...e.components};return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsx)(n.header,{children:(0,r.jsx)(n.h1,{id:"task-fee-escrow",children:"Task Fee Escrow"})}),"\n",(0,r.jsxs)(n.p,{children:["The ",(0,r.jsx)(n.strong,{children:"TaskFeeEscrow"})," is the payment escrow contract for AI agent task execution on the Tokamak AI Layer. Unlike the core registry contracts, it is ",(0,r.jsx)(n.strong,{children:"non-upgradeable"})," and uses native TON (the gas token on Thanos L2) for all payments."]}),"\n",(0,r.jsx)(n.h2,{id:"overview",children:"Overview"}),"\n",(0,r.jsx)(n.p,{children:"The escrow provides a trustless payment mechanism between task clients and AI agents. Funds are held in escrow until the agent owner or operator confirms successful task completion, at which point the funds are credited to the agent's claimable balance. If the task fails, the agent side can issue an immediate refund, or the payer can self-refund after a 1-hour deadline."}),"\n",(0,r.jsx)(n.h3,{id:"key-features",children:"Key Features"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Native TON Payments"})," -- uses ",(0,r.jsx)(n.code,{children:"msg.value"})," for gas-efficient transfers on Thanos L2"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Per-Task Escrow"})," -- each task has its own escrow record identified by a deterministic ",(0,r.jsx)(n.code,{children:"taskRef"})]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Agent Fee Configuration"})," -- agent owners set their per-task fee via ",(0,r.jsx)(n.code,{children:"setAgentFee"})]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Dual Refund Path"})," -- immediate refund by owner/operator, or payer self-refund after deadline"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Usage Tracking"})," -- tracks which users have completed tasks, enabling usage-gated feedback in the Reputation Registry"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Non-Upgradeable"})," -- immutable contract logic for maximum payment security"]}),"\n"]}),"\n",(0,r.jsx)(n.admonition,{title:"Where in the code?",type:"tip",children:(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Contract"}),": ",(0,r.jsx)(n.a,{href:"https://github.com/tokamak-network/Tokamak-AI-Layer/blob/master/contracts/src/core/TaskFeeEscrow.sol",children:(0,r.jsx)(n.code,{children:"contracts/src/core/TaskFeeEscrow.sol"})})," (189 lines)\n",(0,r.jsx)(n.strong,{children:"Interface"}),": ",(0,r.jsx)(n.a,{href:"https://github.com/tokamak-network/Tokamak-AI-Layer/blob/master/contracts/src/interfaces/ITaskFeeEscrow.sol",children:(0,r.jsx)(n.code,{children:"contracts/src/interfaces/ITaskFeeEscrow.sol"})}),"\n",(0,r.jsx)(n.strong,{children:"SDK ABI"}),": ",(0,r.jsx)(n.code,{children:"sdk/src/abi/TaskFeeEscrow.ts"})]})}),"\n",(0,r.jsx)(n.h2,{id:"payment-lifecycle",children:"Payment Lifecycle"}),"\n",(0,r.jsx)(n.mermaid,{value:"sequenceDiagram\n    participant AO as Agent Owner\n    participant U as User / Client\n    participant E as TaskFeeEscrow\n    participant IR as IdentityRegistry\n    participant R as Agent Runtime\n\n    AO->>E: setAgentFee(agentId, feePerTask)\n    Note over E: Fee stored: agentFees[agentId] = fee\n\n    U->>E: payForTask{value: fee}(agentId, taskRef)\n    E->>E: Verify fee matches, store escrow\n    Note over E: Status: Escrowed\n\n    U->>R: Submit task to agent runtime\n    R->>E: isTaskPaid(taskRef)?\n    E--\x3e>R: true\n    R->>R: Execute task\n\n    alt Task Succeeds\n        R->>E: confirmTask(taskRef)\n        E->>IR: ownerOf / getOperator check\n        E->>E: agentBalances[agentId] += amount\n        Note over E: Status: Completed\n        E->>E: _hasUsedAgent[agentId][payer] = true\n\n        AO->>E: claimFees(agentId)\n        E->>AO: Transfer accumulated TON\n    else Task Fails - Agent Refunds\n        R->>E: refundTask(taskRef)\n        E->>IR: ownerOf / getOperator check\n        E->>U: Transfer TON back to payer\n        Note over E: Status: Refunded\n    else Task Fails - Payer Self-Refunds\n        Note over U: Wait 1 hour (REFUND_DEADLINE)\n        U->>E: refundTask(taskRef)\n        E->>U: Transfer TON back\n        Note over E: Status: Refunded\n    end"}),"\n",(0,r.jsx)(n.h2,{id:"function-reference",children:"Function Reference"}),"\n",(0,r.jsx)(n.h3,{id:"agent-owner-functions",children:"Agent Owner Functions"}),"\n",(0,r.jsxs)(n.table,{children:[(0,r.jsx)(n.thead,{children:(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.th,{children:"Function"}),(0,r.jsx)(n.th,{children:"Parameters"}),(0,r.jsx)(n.th,{children:"Returns"}),(0,r.jsx)(n.th,{children:"Description"})]})}),(0,r.jsxs)(n.tbody,{children:[(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:(0,r.jsx)(n.code,{children:"setAgentFee"})}),(0,r.jsx)(n.td,{children:(0,r.jsx)(n.code,{children:"uint256 agentId, uint256 feePerTask"})}),(0,r.jsx)(n.td,{children:"--"}),(0,r.jsx)(n.td,{children:"Set the per-task fee in native TON. Must be > 0. Agent owner only."})]}),(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:(0,r.jsx)(n.code,{children:"claimFees"})}),(0,r.jsx)(n.td,{children:(0,r.jsx)(n.code,{children:"uint256 agentId"})}),(0,r.jsx)(n.td,{children:"--"}),(0,r.jsx)(n.td,{children:"Withdraw all accumulated confirmed fees. Agent owner only. Uses ReentrancyGuard."})]})]})]}),"\n",(0,r.jsx)(n.h3,{id:"user-functions",children:"User Functions"}),"\n",(0,r.jsxs)(n.table,{children:[(0,r.jsx)(n.thead,{children:(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.th,{children:"Function"}),(0,r.jsx)(n.th,{children:"Parameters"}),(0,r.jsx)(n.th,{children:"Returns"}),(0,r.jsx)(n.th,{children:"Description"})]})}),(0,r.jsx)(n.tbody,{children:(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:(0,r.jsx)(n.code,{children:"payForTask"})}),(0,r.jsx)(n.td,{children:(0,r.jsx)(n.code,{children:"uint256 agentId, bytes32 taskRef"})}),(0,r.jsx)(n.td,{children:"--"}),(0,r.jsxs)(n.td,{children:["Pay the task fee via ",(0,r.jsx)(n.code,{children:"msg.value"}),". Must match the agent's configured fee exactly. Payable."]})]})})]}),"\n",(0,r.jsx)(n.h3,{id:"escrow-management",children:"Escrow Management"}),"\n",(0,r.jsxs)(n.table,{children:[(0,r.jsx)(n.thead,{children:(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.th,{children:"Function"}),(0,r.jsx)(n.th,{children:"Parameters"}),(0,r.jsx)(n.th,{children:"Returns"}),(0,r.jsx)(n.th,{children:"Description"})]})}),(0,r.jsxs)(n.tbody,{children:[(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:(0,r.jsx)(n.code,{children:"confirmTask"})}),(0,r.jsx)(n.td,{children:(0,r.jsx)(n.code,{children:"bytes32 taskRef"})}),(0,r.jsx)(n.td,{children:"--"}),(0,r.jsxs)(n.td,{children:["Confirm task completion, moving escrow to ",(0,r.jsx)(n.code,{children:"agentBalances"}),". Agent owner or operator only."]})]}),(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:(0,r.jsx)(n.code,{children:"refundTask"})}),(0,r.jsx)(n.td,{children:(0,r.jsx)(n.code,{children:"bytes32 taskRef"})}),(0,r.jsx)(n.td,{children:"--"}),(0,r.jsxs)(n.td,{children:["Refund escrowed funds. Owner/operator can refund immediately. Payer can refund after ",(0,r.jsx)(n.code,{children:"REFUND_DEADLINE"})," (1 hour)."]})]})]})]}),"\n",(0,r.jsx)(n.h3,{id:"view-functions",children:"View Functions"}),"\n",(0,r.jsxs)(n.table,{children:[(0,r.jsx)(n.thead,{children:(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.th,{children:"Function"}),(0,r.jsx)(n.th,{children:"Parameters"}),(0,r.jsx)(n.th,{children:"Returns"}),(0,r.jsx)(n.th,{children:"Description"})]})}),(0,r.jsxs)(n.tbody,{children:[(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:(0,r.jsx)(n.code,{children:"isTaskPaid"})}),(0,r.jsx)(n.td,{children:(0,r.jsx)(n.code,{children:"bytes32 taskRef"})}),(0,r.jsx)(n.td,{children:(0,r.jsx)(n.code,{children:"bool"})}),(0,r.jsxs)(n.td,{children:["Returns ",(0,r.jsx)(n.code,{children:"true"})," if status is ",(0,r.jsx)(n.code,{children:"Escrowed"})," or ",(0,r.jsx)(n.code,{children:"Completed"}),"."]})]}),(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:(0,r.jsx)(n.code,{children:"getAgentFee"})}),(0,r.jsx)(n.td,{children:(0,r.jsx)(n.code,{children:"uint256 agentId"})}),(0,r.jsx)(n.td,{children:(0,r.jsx)(n.code,{children:"uint256"})}),(0,r.jsx)(n.td,{children:"Current per-task fee. Returns 0 if not set."})]}),(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:(0,r.jsx)(n.code,{children:"getAgentBalance"})}),(0,r.jsx)(n.td,{children:(0,r.jsx)(n.code,{children:"uint256 agentId"})}),(0,r.jsx)(n.td,{children:(0,r.jsx)(n.code,{children:"uint256"})}),(0,r.jsx)(n.td,{children:"Accumulated unclaimed balance."})]}),(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:(0,r.jsx)(n.code,{children:"getTaskEscrow"})}),(0,r.jsx)(n.td,{children:(0,r.jsx)(n.code,{children:"bytes32 taskRef"})}),(0,r.jsx)(n.td,{children:(0,r.jsx)(n.code,{children:"TaskEscrow"})}),(0,r.jsx)(n.td,{children:"Full escrow record: payer, agentId, amount, paidAt, status."})]}),(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:(0,r.jsx)(n.code,{children:"hasUsedAgent"})}),(0,r.jsx)(n.td,{children:(0,r.jsx)(n.code,{children:"uint256 agentId, address user"})}),(0,r.jsx)(n.td,{children:(0,r.jsx)(n.code,{children:"bool"})}),(0,r.jsx)(n.td,{children:"Whether the user has completed at least one task for this agent."})]})]})]}),"\n",(0,r.jsx)(n.h2,{id:"events",children:"Events"}),"\n",(0,r.jsxs)(n.table,{children:[(0,r.jsx)(n.thead,{children:(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.th,{children:"Event"}),(0,r.jsx)(n.th,{children:"Parameters"}),(0,r.jsx)(n.th,{children:"Description"})]})}),(0,r.jsxs)(n.tbody,{children:[(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:(0,r.jsx)(n.code,{children:"AgentFeeSet"})}),(0,r.jsx)(n.td,{children:(0,r.jsx)(n.code,{children:"uint256 indexed agentId, uint256 feePerTask"})}),(0,r.jsx)(n.td,{children:"Agent fee configured or updated."})]}),(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:(0,r.jsx)(n.code,{children:"TaskPaid"})}),(0,r.jsx)(n.td,{children:(0,r.jsx)(n.code,{children:"uint256 indexed agentId, address indexed payer, bytes32 indexed taskRef, uint256 amount"})}),(0,r.jsx)(n.td,{children:"Task fee paid, funds in escrow."})]}),(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:(0,r.jsx)(n.code,{children:"TaskConfirmed"})}),(0,r.jsx)(n.td,{children:(0,r.jsx)(n.code,{children:"bytes32 indexed taskRef, uint256 indexed agentId, uint256 amount"})}),(0,r.jsx)(n.td,{children:"Task confirmed, funds credited to agent balance."})]}),(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:(0,r.jsx)(n.code,{children:"TaskRefunded"})}),(0,r.jsx)(n.td,{children:(0,r.jsx)(n.code,{children:"bytes32 indexed taskRef, address indexed payer, uint256 amount"})}),(0,r.jsx)(n.td,{children:"Escrow refunded to payer."})]}),(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:(0,r.jsx)(n.code,{children:"FeesClaimed"})}),(0,r.jsx)(n.td,{children:(0,r.jsx)(n.code,{children:"uint256 indexed agentId, address indexed owner, uint256 amount"})}),(0,r.jsx)(n.td,{children:"Agent owner withdrew accumulated fees."})]})]})]}),"\n",(0,r.jsx)(n.h2,{id:"data-structures",children:"Data Structures"}),"\n",(0,r.jsx)(n.h3,{id:"taskstatus-enum",children:"TaskStatus Enum"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-solidity",children:"enum TaskStatus {\n    None,       // 0 - No escrow exists\n    Escrowed,   // 1 - Funds held, pending confirmation\n    Completed,  // 2 - Confirmed, funds in agentBalances\n    Refunded    // 3 - Refunded to payer\n}\n"})}),"\n",(0,r.jsx)(n.h3,{id:"taskescrow-struct",children:"TaskEscrow Struct"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-solidity",children:"struct TaskEscrow {\n    address payer;      // The address that paid\n    uint256 agentId;    // The agent being paid\n    uint256 amount;     // Native TON escrowed\n    uint256 paidAt;     // Block timestamp when paid\n    TaskStatus status;  // Current escrow status\n}\n"})}),"\n",(0,r.jsx)(n.h2,{id:"constants",children:"Constants"}),"\n",(0,r.jsxs)(n.table,{children:[(0,r.jsx)(n.thead,{children:(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.th,{children:"Constant"}),(0,r.jsx)(n.th,{children:"Value"}),(0,r.jsx)(n.th,{children:"Description"})]})}),(0,r.jsx)(n.tbody,{children:(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:(0,r.jsx)(n.code,{children:"REFUND_DEADLINE"})}),(0,r.jsxs)(n.td,{children:[(0,r.jsx)(n.code,{children:"1 hours"})," (3600 seconds)"]}),(0,r.jsx)(n.td,{children:"Time after which the payer can self-refund"})]})})]}),"\n",(0,r.jsx)(n.h2,{id:"iidentityregistryminimal-interface",children:"IIdentityRegistryMinimal Interface"}),"\n",(0,r.jsx)(n.p,{children:"The escrow uses a minimal interface to interact with the Identity Registry, reducing coupling:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-solidity",children:"interface IIdentityRegistryMinimal {\n    function ownerOf(uint256 tokenId) external view returns (address);\n    function getOperator(uint256 agentId) external view returns (address);\n}\n"})}),"\n",(0,r.jsx)(n.p,{children:"This interface is used for:"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsxs)(n.strong,{children:[(0,r.jsx)(n.code,{children:"onlyAgentOwner"})," modifier"]})," -- verifying the caller owns the agent NFT"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsxs)(n.strong,{children:[(0,r.jsx)(n.code,{children:"_isOwnerOrOperator"})," check"]})," -- allowing both the owner and the designated operator to confirm/refund tasks"]}),"\n"]}),"\n",(0,r.jsx)(n.admonition,{title:"Refund Deadline",type:"warning",children:(0,r.jsxs)(n.p,{children:["The payer can only self-refund after the ",(0,r.jsxs)(n.strong,{children:["1-hour ",(0,r.jsx)(n.code,{children:"REFUND_DEADLINE"})]})," has passed since payment. Before that, only the agent owner or operator can initiate a refund. This gives the agent sufficient time to execute the task before the client can reclaim funds."]})}),"\n",(0,r.jsx)(n.h2,{id:"code-example-full-payment-flow",children:"Code Example: Full Payment Flow"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-solidity",children:'// Step 1: Agent owner sets fee (0.1 TON per task)\ntaskFeeEscrow.setAgentFee(agentId, 0.1 ether);\n\n// Step 2: User pays for a task\nbytes32 taskRef = keccak256(abi.encodePacked(agentId, msg.sender, nonce));\ntaskFeeEscrow.payForTask{value: 0.1 ether}(agentId, taskRef);\n\n// Step 3: Runtime checks payment\nbool paid = taskFeeEscrow.isTaskPaid(taskRef);\nrequire(paid, "Task not paid");\n\n// Step 4a: On success, agent operator confirms\ntaskFeeEscrow.confirmTask(taskRef);\n\n// Step 4b: On failure, operator refunds immediately\ntaskFeeEscrow.refundTask(taskRef);\n\n// Step 4c: Or payer self-refunds after 1 hour\n// (only if still in Escrowed status)\ntaskFeeEscrow.refundTask(taskRef);\n\n// Step 5: Agent owner claims accumulated fees\ntaskFeeEscrow.claimFees(agentId);\n'})}),"\n",(0,r.jsx)(n.admonition,{title:"Usage-Gated Feedback",type:"info",children:(0,r.jsxs)(n.p,{children:["When the ",(0,r.jsx)(n.code,{children:"TaskFeeEscrow"})," address is set on the ",(0,r.jsx)(n.code,{children:"TALReputationRegistry"})," via ",(0,r.jsx)(n.code,{children:"setTaskFeeEscrow"}),", only users with ",(0,r.jsx)(n.code,{children:"hasUsedAgent(agentId, user) == true"})," can submit feedback. This is set to ",(0,r.jsx)(n.code,{children:"true"})," when ",(0,r.jsx)(n.code,{children:"confirmTask"})," is called, ensuring only actual task consumers can rate agents."]})}),"\n",(0,r.jsx)(n.h2,{id:"security-considerations",children:"Security Considerations"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Non-Upgradeable"}),": Unlike the core registries, TaskFeeEscrow is deployed as a plain contract (no proxy). This provides stronger payment security guarantees since the logic cannot be changed after deployment."]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"ReentrancyGuard"}),": Applied to ",(0,r.jsx)(n.code,{children:"payForTask"}),", ",(0,r.jsx)(n.code,{children:"confirmTask"}),", ",(0,r.jsx)(n.code,{children:"refundTask"}),", and ",(0,r.jsx)(n.code,{children:"claimFees"})," to prevent reentrancy attacks during native TON transfers."]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Exact Fee Matching"}),": ",(0,r.jsx)(n.code,{children:"msg.value"})," must exactly equal the configured fee -- no overpayment or underpayment is accepted."]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Immutable Registry Reference"}),": The ",(0,r.jsx)(n.code,{children:"identityRegistry"})," address is set at construction time and cannot be changed."]}),"\n"]}),"\n",(0,r.jsx)(n.h2,{id:"related-pages",children:"Related Pages"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.a,{href:"./identity-registry",children:"Identity Registry"})," -- agent ownership and operator verification"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.a,{href:"./reputation-registry",children:"Reputation Registry"})," -- uses ",(0,r.jsx)(n.code,{children:"hasUsedAgent"})," for feedback gating"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.a,{href:"./deployment-and-security",children:"Deployment & Security"})," -- security patterns and deployed addresses"]}),"\n"]})]})}function h(e={}){const{wrapper:n}={...(0,i.R)(),...e.components};return n?(0,r.jsx)(n,{...e,children:(0,r.jsx)(o,{...e})}):o(e)}},8453(e,n,s){s.d(n,{R:()=>d,x:()=>a});var t=s(6540);const r={},i=t.createContext(r);function d(e){const n=t.useContext(i);return t.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function a(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(r):e.components||r:d(e.components),t.createElement(i.Provider,{value:n},e.children)}}}]);