"use strict";(globalThis.webpackChunktal_docs=globalThis.webpackChunktal_docs||[]).push([[8136],{9317(e,t,n){n.r(t),n.d(t,{assets:()=>o,contentTitle:()=>d,default:()=>h,frontMatter:()=>a,metadata:()=>i,toc:()=>l});const i=JSON.parse('{"id":"integration/drb-integration","title":"DRB Integration","description":"The DRBIntegrationModule wraps Tokamak\'s DRB Commit-Reveal2 protocol to provide fair, verifiable random validator selection for the TAL validation system. It ensures no party can predict or manipulate which validator is assigned to verify an agent\'s output.","source":"@site/docs/integration/drb-integration.md","sourceDirName":"integration","slug":"/integration/drb-integration","permalink":"/tal/integration/drb-integration","draft":false,"unlisted":false,"editUrl":"https://github.com/tokamak-network/Tokamak-AI-Layer/tree/master/docs/docs/integration/drb-integration.md","tags":[],"version":"current","sidebarPosition":2,"frontMatter":{"title":"DRB Integration","sidebar_position":2},"sidebar":"docsSidebar","previous":{"title":"Staking Bridge","permalink":"/tal/integration/staking-bridge"},"next":{"title":"IPFS & Metadata","permalink":"/tal/integration/ipfs-and-metadata"}}');var r=n(4848),s=n(8453);const a={title:"DRB Integration",sidebar_position:2},d="DRB Integration",o={},l=[{value:"Overview",id:"overview",level:2},{value:"Commit-Reveal2 Protocol",id:"commit-reveal2-protocol",level:2},{value:"Validator Selection Algorithm",id:"validator-selection-algorithm",level:2},{value:"Async Callback Flow",id:"async-callback-flow",level:2},{value:"Function Reference",id:"function-reference",level:2},{value:"Core Functions",id:"core-functions",level:3},{value:"View Functions",id:"view-functions",level:3},{value:"Admin Functions",id:"admin-functions",level:3},{value:"Fee Estimation",id:"fee-estimation",level:2},{value:"Configuration",id:"configuration",level:2},{value:"Next Steps",id:"next-steps",level:2}];function c(e){const t={a:"a",admonition:"admonition",code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",li:"li",mermaid:"mermaid",ol:"ol",p:"p",pre:"pre",strong:"strong",table:"table",tbody:"tbody",td:"td",th:"th",thead:"thead",tr:"tr",ul:"ul",...(0,s.R)(),...e.components};return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsx)(t.header,{children:(0,r.jsx)(t.h1,{id:"drb-integration",children:"DRB Integration"})}),"\n",(0,r.jsxs)(t.p,{children:["The ",(0,r.jsx)(t.code,{children:"DRBIntegrationModule"})," wraps Tokamak's ",(0,r.jsx)(t.strong,{children:"DRB Commit-Reveal2"})," protocol to provide fair, verifiable random validator selection for the TAL validation system. It ensures no party can predict or manipulate which validator is assigned to verify an agent's output."]}),"\n",(0,r.jsx)(t.h2,{id:"overview",children:"Overview"}),"\n",(0,r.jsx)(t.p,{children:"DRB (Distributed Random Beacon) produces verifiable random numbers through a multi-operator commit-reveal protocol. TAL uses these random numbers to select validators from a stake-weighted candidate pool, ensuring that higher-staked operators have proportionally higher selection probability."}),"\n",(0,r.jsx)(t.mermaid,{value:"graph LR\n    A[TALValidationRegistry] --\x3e|requestValidatorSelection| B[DRBIntegrationModule]\n    B --\x3e|requestRandomNumber + ETH| C[CommitReveal2 Coordinator]\n    C --\x3e|Commit-Reveal2 Protocol| D[DRB Operators]\n    D --\x3e|rawFulfillRandomNumber| B\n    B --\x3e|finalizeValidatorSelection| E[Selected Validator]"}),"\n",(0,r.jsx)(t.h2,{id:"commit-reveal2-protocol",children:"Commit-Reveal2 Protocol"}),"\n",(0,r.jsx)(t.p,{children:"The Commit-Reveal2 protocol operates in two phases to generate verifiable randomness:"}),"\n",(0,r.jsx)(t.mermaid,{value:"sequenceDiagram\n    participant TAL as DRBIntegrationModule\n    participant CR2 as CommitReveal2 Coordinator\n    participant Op1 as DRB Operator 1\n    participant Op2 as DRB Operator 2\n    participant OpN as DRB Operator N\n\n    TAL->>CR2: requestRandomNumber{value}(callbackGasLimit)\n    CR2--\x3e>TAL: drbRound\n\n    Note over Op1,OpN: Phase 1: Commit\n    Op1->>CR2: commit(round, hash(secret1))\n    Op2->>CR2: commit(round, hash(secret2))\n    OpN->>CR2: commit(round, hash(secretN))\n\n    Note over Op1,OpN: Phase 2: Reveal\n    Op1->>CR2: reveal(round, secret1)\n    Op2->>CR2: reveal(round, secret2)\n    OpN->>CR2: reveal(round, secretN)\n\n    Note over CR2: Combine reveals into random number\n    CR2->>TAL: rawFulfillRandomNumber(round, randomNumber)\n\n    Note over TAL: Use random number for weighted selection\n    TAL->>TAL: finalizeValidatorSelection(candidates, stakes, randomValue)"}),"\n",(0,r.jsxs)(t.p,{children:[(0,r.jsx)(t.strong,{children:"Phase 1 -- Commit:"})," Each DRB operator submits a hash of their secret value. This locks in their contribution without revealing it."]}),"\n",(0,r.jsxs)(t.p,{children:[(0,r.jsx)(t.strong,{children:"Phase 2 -- Reveal:"})," Operators reveal their secrets. The coordinator verifies each reveal matches the committed hash, then combines all reveals to produce the final random number."]}),"\n",(0,r.jsx)(t.h2,{id:"validator-selection-algorithm",children:"Validator Selection Algorithm"}),"\n",(0,r.jsxs)(t.p,{children:["The selection uses a ",(0,r.jsx)(t.strong,{children:"cumulative sum approach"})," with stake-based weights:"]}),"\n",(0,r.jsxs)(t.ol,{children:["\n",(0,r.jsxs)(t.li,{children:["Sum all candidate stakes to compute ",(0,r.jsx)(t.code,{children:"totalWeight"})]}),"\n",(0,r.jsxs)(t.li,{children:["Calculate ",(0,r.jsx)(t.code,{children:"threshold = randomValue % totalWeight"})]}),"\n",(0,r.jsx)(t.li,{children:"Iterate through candidates, accumulating weights"}),"\n",(0,r.jsx)(t.li,{children:"Select the first candidate whose cumulative weight exceeds the threshold"}),"\n"]}),"\n",(0,r.jsx)(t.pre,{children:(0,r.jsx)(t.code,{className:"language-solidity",children:"// Simplified selection logic\nuint256 threshold = randomValue % totalWeight;\nuint256 cumulative = 0;\n\nfor (uint256 i = 0; i < candidates.length; i++) {\n    cumulative += weights[i];\n    if (threshold < cumulative) {\n        return candidates[i];  // Selected!\n    }\n}\n"})}),"\n",(0,r.jsx)(t.p,{children:"This gives each candidate a selection probability proportional to their stake:"}),"\n",(0,r.jsxs)(t.table,{children:[(0,r.jsx)(t.thead,{children:(0,r.jsxs)(t.tr,{children:[(0,r.jsx)(t.th,{children:"Candidate"}),(0,r.jsx)(t.th,{children:"Stake"}),(0,r.jsx)(t.th,{children:"Probability"})]})}),(0,r.jsxs)(t.tbody,{children:[(0,r.jsxs)(t.tr,{children:[(0,r.jsx)(t.td,{children:"Operator A"}),(0,r.jsx)(t.td,{children:"5,000 TON"}),(0,r.jsx)(t.td,{children:"5,000 / 16,000 = 31.25%"})]}),(0,r.jsxs)(t.tr,{children:[(0,r.jsx)(t.td,{children:"Operator B"}),(0,r.jsx)(t.td,{children:"10,000 TON"}),(0,r.jsx)(t.td,{children:"10,000 / 16,000 = 62.50%"})]}),(0,r.jsxs)(t.tr,{children:[(0,r.jsx)(t.td,{children:"Operator C"}),(0,r.jsx)(t.td,{children:"1,000 TON"}),(0,r.jsx)(t.td,{children:"1,000 / 16,000 = 6.25%"})]})]})]}),"\n",(0,r.jsx)(t.admonition,{title:"Randomness Guarantees",type:"info",children:(0,r.jsx)(t.p,{children:"The DRB protocol guarantees that no single operator can predict or bias the random output, as long as at least one operator is honest. The random number is derived from all participants' secrets, making it infeasible to manipulate without controlling all DRB operators."})}),"\n",(0,r.jsx)(t.h2,{id:"async-callback-flow",children:"Async Callback Flow"}),"\n",(0,r.jsxs)(t.p,{children:["The selection process is ",(0,r.jsx)(t.strong,{children:"asynchronous"})," because DRB randomness generation requires multiple transactions across the commit and reveal phases:"]}),"\n",(0,r.jsx)(t.mermaid,{value:"stateDiagram-v2\n    [*] --\x3e RequestSent: requestValidatorSelection()\n    RequestSent --\x3e WaitingForDRB: DRB round assigned\n    WaitingForDRB --\x3e RandomnessReceived: rawFulfillRandomNumber() callback\n    RandomnessReceived --\x3e ValidatorSelected: finalizeValidatorSelection()\n    ValidatorSelected --\x3e [*]"}),"\n",(0,r.jsxs)(t.ol,{children:["\n",(0,r.jsxs)(t.li,{children:[(0,r.jsx)(t.code,{children:"requestValidatorSelection()"})," -- Sends ETH fee to CommitReveal2 and gets a DRB round number"]}),"\n",(0,r.jsx)(t.li,{children:"DRB operators run the commit-reveal protocol (off-chain coordination)"}),"\n",(0,r.jsxs)(t.li,{children:[(0,r.jsx)(t.code,{children:"rawFulfillRandomNumber()"})," -- Coordinator calls back with the random number"]}),"\n",(0,r.jsxs)(t.li,{children:[(0,r.jsx)(t.code,{children:"finalizeValidatorSelection()"})," -- Uses the random number to select from the candidate list"]}),"\n"]}),"\n",(0,r.jsx)(t.h2,{id:"function-reference",children:"Function Reference"}),"\n",(0,r.jsx)(t.h3,{id:"core-functions",children:"Core Functions"}),"\n",(0,r.jsxs)(t.table,{children:[(0,r.jsx)(t.thead,{children:(0,r.jsxs)(t.tr,{children:[(0,r.jsx)(t.th,{children:"Function"}),(0,r.jsx)(t.th,{children:"Parameters"}),(0,r.jsx)(t.th,{children:"Returns"}),(0,r.jsx)(t.th,{children:"Description"})]})}),(0,r.jsxs)(t.tbody,{children:[(0,r.jsxs)(t.tr,{children:[(0,r.jsx)(t.td,{children:(0,r.jsx)(t.code,{children:"requestValidatorSelection"})}),(0,r.jsx)(t.td,{children:(0,r.jsx)(t.code,{children:"requestHash: bytes32, candidates: address[], stakes: uint256[]"})}),(0,r.jsx)(t.td,{children:(0,r.jsx)(t.code,{children:"uint256 drbRound"})}),(0,r.jsx)(t.td,{children:"Initiate DRB randomness request (payable, VALIDATOR_SELECTOR_ROLE)"})]}),(0,r.jsxs)(t.tr,{children:[(0,r.jsx)(t.td,{children:(0,r.jsx)(t.code,{children:"rawFulfillRandomNumber"})}),(0,r.jsx)(t.td,{children:(0,r.jsx)(t.code,{children:"round: uint256, randomNumber: uint256"})}),(0,r.jsx)(t.td,{children:"--"}),(0,r.jsx)(t.td,{children:"DRB callback (coordinator only)"})]}),(0,r.jsxs)(t.tr,{children:[(0,r.jsx)(t.td,{children:(0,r.jsx)(t.code,{children:"finalizeValidatorSelection"})}),(0,r.jsx)(t.td,{children:(0,r.jsx)(t.code,{children:"requestHash: bytes32, candidates: address[], stakes: uint256[]"})}),(0,r.jsx)(t.td,{children:(0,r.jsx)(t.code,{children:"address selected"})}),(0,r.jsx)(t.td,{children:"Complete selection after randomness arrives (VALIDATOR_SELECTOR_ROLE)"})]}),(0,r.jsxs)(t.tr,{children:[(0,r.jsx)(t.td,{children:(0,r.jsx)(t.code,{children:"selectFromWeightedList"})}),(0,r.jsx)(t.td,{children:(0,r.jsx)(t.code,{children:"candidates: address[], weights: uint256[], randomValue: uint256"})}),(0,r.jsx)(t.td,{children:(0,r.jsx)(t.code,{children:"address selected"})}),(0,r.jsx)(t.td,{children:"Pure weighted selection (no state changes)"})]})]})]}),"\n",(0,r.jsx)(t.h3,{id:"view-functions",children:"View Functions"}),"\n",(0,r.jsxs)(t.table,{children:[(0,r.jsx)(t.thead,{children:(0,r.jsxs)(t.tr,{children:[(0,r.jsx)(t.th,{children:"Function"}),(0,r.jsx)(t.th,{children:"Parameters"}),(0,r.jsx)(t.th,{children:"Returns"}),(0,r.jsx)(t.th,{children:"Description"})]})}),(0,r.jsxs)(t.tbody,{children:[(0,r.jsxs)(t.tr,{children:[(0,r.jsx)(t.td,{children:(0,r.jsx)(t.code,{children:"isRandomnessReceived"})}),(0,r.jsx)(t.td,{children:(0,r.jsx)(t.code,{children:"round: uint256"})}),(0,r.jsx)(t.td,{children:(0,r.jsx)(t.code,{children:"bool"})}),(0,r.jsx)(t.td,{children:"Check if a DRB round has delivered randomness"})]}),(0,r.jsxs)(t.tr,{children:[(0,r.jsx)(t.td,{children:(0,r.jsx)(t.code,{children:"getSelectedValidator"})}),(0,r.jsx)(t.td,{children:(0,r.jsx)(t.code,{children:"requestHash: bytes32"})}),(0,r.jsx)(t.td,{children:(0,r.jsx)(t.code,{children:"address"})}),(0,r.jsx)(t.td,{children:"Get the selected validator for a request"})]}),(0,r.jsxs)(t.tr,{children:[(0,r.jsx)(t.td,{children:(0,r.jsx)(t.code,{children:"estimateRequestFee"})}),(0,r.jsx)(t.td,{children:(0,r.jsx)(t.code,{children:"callbackGasLimit: uint32"})}),(0,r.jsx)(t.td,{children:(0,r.jsx)(t.code,{children:"uint256"})}),(0,r.jsx)(t.td,{children:"Estimate the ETH fee for a DRB request"})]}),(0,r.jsxs)(t.tr,{children:[(0,r.jsx)(t.td,{children:(0,r.jsx)(t.code,{children:"getDRBRound"})}),(0,r.jsx)(t.td,{children:(0,r.jsx)(t.code,{children:"requestHash: bytes32"})}),(0,r.jsx)(t.td,{children:(0,r.jsx)(t.code,{children:"uint256"})}),(0,r.jsx)(t.td,{children:"Get the DRB round number for a request"})]})]})]}),"\n",(0,r.jsx)(t.h3,{id:"admin-functions",children:"Admin Functions"}),"\n",(0,r.jsxs)(t.table,{children:[(0,r.jsx)(t.thead,{children:(0,r.jsxs)(t.tr,{children:[(0,r.jsx)(t.th,{children:"Function"}),(0,r.jsx)(t.th,{children:"Parameters"}),(0,r.jsx)(t.th,{children:"Description"})]})}),(0,r.jsxs)(t.tbody,{children:[(0,r.jsxs)(t.tr,{children:[(0,r.jsx)(t.td,{children:(0,r.jsx)(t.code,{children:"setCoordinator"})}),(0,r.jsx)(t.td,{children:(0,r.jsx)(t.code,{children:"coordinator_: address"})}),(0,r.jsx)(t.td,{children:"Update CommitReveal2 coordinator address (DEFAULT_ADMIN_ROLE)"})]}),(0,r.jsxs)(t.tr,{children:[(0,r.jsx)(t.td,{children:(0,r.jsx)(t.code,{children:"setCallbackGasLimit"})}),(0,r.jsx)(t.td,{children:(0,r.jsx)(t.code,{children:"callbackGasLimit_: uint32"})}),(0,r.jsx)(t.td,{children:"Update callback gas limit (DEFAULT_ADMIN_ROLE)"})]})]})]}),"\n",(0,r.jsx)(t.h2,{id:"fee-estimation",children:"Fee Estimation"}),"\n",(0,r.jsx)(t.p,{children:"Before requesting validator selection, estimate the required fee:"}),"\n",(0,r.jsx)(t.pre,{children:(0,r.jsx)(t.code,{className:"language-typescript",children:"import { createPublicClient, http, parseEther } from 'viem';\nimport { optimismSepolia } from 'viem/chains';\n\nconst publicClient = createPublicClient({\n  chain: optimismSepolia,\n  transport: http('https://sepolia.optimism.io'),\n});\n\n// Estimate the DRB request fee\nconst fee = await publicClient.readContract({\n  address: DRB_MODULE_ADDRESS,\n  abi: DRBIntegrationModuleABI,\n  functionName: 'estimateRequestFee',\n  args: [100_000], // callbackGasLimit\n});\n\nconsole.log(`Estimated fee: ${fee} wei`);\n"})}),"\n",(0,r.jsx)(t.admonition,{title:"Excess Fee Refund",type:"tip",children:(0,r.jsx)(t.p,{children:"If you send more ETH than the estimated fee, the excess is automatically refunded to the caller. It is safe to slightly overpay to account for gas price fluctuations."})}),"\n",(0,r.jsx)(t.h2,{id:"configuration",children:"Configuration"}),"\n",(0,r.jsxs)(t.table,{children:[(0,r.jsx)(t.thead,{children:(0,r.jsxs)(t.tr,{children:[(0,r.jsx)(t.th,{children:"Parameter"}),(0,r.jsx)(t.th,{children:"Default"}),(0,r.jsx)(t.th,{children:"Description"})]})}),(0,r.jsxs)(t.tbody,{children:[(0,r.jsxs)(t.tr,{children:[(0,r.jsx)(t.td,{children:(0,r.jsx)(t.code,{children:"callbackGasLimit"})}),(0,r.jsx)(t.td,{children:"100,000 gas"}),(0,r.jsx)(t.td,{children:"Gas limit for the DRB callback transaction"})]}),(0,r.jsxs)(t.tr,{children:[(0,r.jsx)(t.td,{children:(0,r.jsx)(t.code,{children:"coordinator"})}),(0,r.jsx)(t.td,{children:"Set at initialization"}),(0,r.jsx)(t.td,{children:"CommitReveal2 coordinator contract address"})]})]})]}),"\n",(0,r.jsx)(t.h2,{id:"next-steps",children:"Next Steps"}),"\n",(0,r.jsxs)(t.ul,{children:["\n",(0,r.jsxs)(t.li,{children:[(0,r.jsx)(t.a,{href:"./staking-bridge",children:"Staking Bridge"})," -- How operator stakes back the validation system"]}),"\n",(0,r.jsxs)(t.li,{children:[(0,r.jsx)(t.a,{href:"../sdk/reputation-and-validation",children:"Reputation & Validation"})," -- Request validations from the SDK"]}),"\n",(0,r.jsxs)(t.li,{children:[(0,r.jsx)(t.a,{href:"./ipfs-and-metadata",children:"IPFS & Metadata"})," -- Store validation details on IPFS"]}),"\n"]})]})}function h(e={}){const{wrapper:t}={...(0,s.R)(),...e.components};return t?(0,r.jsx)(t,{...e,children:(0,r.jsx)(c,{...e})}):c(e)}},8453(e,t,n){n.d(t,{R:()=>a,x:()=>d});var i=n(6540);const r={},s=i.createContext(r);function a(e){const t=i.useContext(s);return i.useMemo(function(){return"function"==typeof e?e(t):{...t,...e}},[t,e])}function d(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(r):e.components||r:a(e.components),i.createElement(s.Provider,{value:t},e.children)}}}]);