"use strict";(globalThis.webpackChunktal_docs=globalThis.webpackChunktal_docs||[]).push([[4691],{5470(e,t,n){n.r(t),n.d(t,{assets:()=>o,contentTitle:()=>d,default:()=>h,frontMatter:()=>a,metadata:()=>r,toc:()=>c});const r=JSON.parse('{"id":"integration/staking-bridge","title":"Staking Bridge","description":"The TAL Staking Bridge provides cross-layer economic security by bridging TON Staking V3 data from Ethereum L1 to Tokamak L2. Operator stakes on L1 back the validation and slashing mechanisms on L2, creating a trustless economic security layer.","source":"@site/docs/integration/staking-bridge.md","sourceDirName":"integration","slug":"/integration/staking-bridge","permalink":"/integration/staking-bridge","draft":false,"unlisted":false,"editUrl":"https://github.com/tokamak-network/Tokamak-AI-Layer/tree/master/docs/docs/integration/staking-bridge.md","tags":[],"version":"current","sidebarPosition":1,"frontMatter":{"title":"Staking Bridge","sidebar_position":1},"sidebar":"docsSidebar","previous":{"title":"Contract Integration","permalink":"/app/contract-integration"},"next":{"title":"DRB Integration","permalink":"/integration/drb-integration"}}');var i=n(4848),s=n(8453);const a={title:"Staking Bridge",sidebar_position:1},d="Staking Bridge",o={},c=[{value:"Architecture Overview",id:"architecture-overview",level:2},{value:"Staking Flow",id:"staking-flow",level:2},{value:"L1 Bridge: TALStakingBridgeL1",id:"l1-bridge-talstakingbridgel1",level:2},{value:"Key Functions",id:"key-functions",level:3},{value:"Roles",id:"roles",level:3},{value:"L2 Bridge: TALStakingBridgeL2",id:"l2-bridge-talstakingbridgel2",level:2},{value:"Operator Tiers",id:"operator-tiers",level:3},{value:"StakeSnapshot Structure",id:"stakesnapshot-structure",level:3},{value:"Cache Freshness",id:"cache-freshness",level:3},{value:"StakingIntegrationModule",id:"stakingintegrationmodule",level:2},{value:"Key Functions",id:"key-functions-1",level:3},{value:"Slashing Conditions",id:"slashing-conditions",level:3},{value:"Frontend Integration",id:"frontend-integration",level:2},{value:"Next Steps",id:"next-steps",level:2}];function l(e){const t={a:"a",admonition:"admonition",code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",li:"li",mermaid:"mermaid",p:"p",pre:"pre",strong:"strong",table:"table",tbody:"tbody",td:"td",th:"th",thead:"thead",tr:"tr",ul:"ul",...(0,s.R)(),...e.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(t.header,{children:(0,i.jsx)(t.h1,{id:"staking-bridge",children:"Staking Bridge"})}),"\n",(0,i.jsxs)(t.p,{children:["The TAL Staking Bridge provides ",(0,i.jsx)(t.strong,{children:"cross-layer economic security"})," by bridging TON Staking V3 data from Ethereum L1 to Tokamak L2. Operator stakes on L1 back the validation and slashing mechanisms on L2, creating a trustless economic security layer."]}),"\n",(0,i.jsx)(t.h2,{id:"architecture-overview",children:"Architecture Overview"}),"\n",(0,i.jsx)(t.mermaid,{value:"graph TB\n    subgraph Ethereum L1\n        A[TON Token] --\x3e|approve| B[WTON]\n        B --\x3e|deposit| C[DepositManager]\n        C --\x3e|stake| D[SeigManager / Staking V3]\n        D --\x3e|stakeOf query| E[TALStakingBridgeL1]\n        E --\x3e|L1CrossDomainMessenger| F[Relay Stake Data]\n    end\n\n    subgraph Tokamak L2\n        F --\x3e|L2CrossDomainMessenger| G[TALStakingBridgeL2]\n        G --\x3e|cache| H[StakeSnapshot]\n        H --\x3e|query| I[StakingIntegrationModule]\n        I --\x3e|isVerifiedOperator| J[TALIdentityRegistry]\n        I --\x3e|stake-weighted scoring| K[TALReputationRegistry]\n        I --\x3e|validator selection| L[TALValidationRegistry]\n    end"}),"\n",(0,i.jsx)(t.h2,{id:"staking-flow",children:"Staking Flow"}),"\n",(0,i.jsx)(t.p,{children:"The full staking flow involves multiple steps across L1 and L2:"}),"\n",(0,i.jsx)(t.mermaid,{value:"sequenceDiagram\n    participant Op as Operator\n    participant TON as TON Token (L1)\n    participant WTON as WTON Token (L1)\n    participant DM as DepositManager (L1)\n    participant SM as SeigManager (L1)\n    participant L1B as TALStakingBridgeL1\n    participant CDM as CrossDomainMessenger\n    participant L2B as TALStakingBridgeL2\n    participant SIM as StakingIntegrationModule\n\n    Note over Op,SM: Step 1: Stake on L1\n    Op->>TON: approve(WTON, amount)\n    Op->>WTON: swapFromTON(amount)\n    Op->>WTON: approve(DepositManager, amount)\n    Op->>DM: deposit(layer2, amount)\n    Op->>SM: stake(layer2)\n\n    Note over L1B,L2B: Step 2: Relay to L2\n    L1B->>SM: stakeOf(layer2, operator)\n    SM--\x3e>L1B: stakeAmount\n    L1B->>CDM: sendMessage(l2Bridge, updateStake)\n    CDM--\x3e>L2B: receiveStakeUpdate(operator, amount)\n\n    Note over L2B,SIM: Step 3: L2 Cache & Query\n    L2B->>L2B: Cache StakeSnapshot\n    L2B->>L2B: Update OperatorTier\n    SIM->>L2B: getOperatorStake(operator)\n    L2B--\x3e>SIM: cachedAmount"}),"\n",(0,i.jsx)(t.h2,{id:"l1-bridge-talstakingbridgel1",children:"L1 Bridge: TALStakingBridgeL1"}),"\n",(0,i.jsx)(t.p,{children:"The L1 bridge contract queries the SeigManager for operator stake amounts and relays them to L2."}),"\n",(0,i.jsx)(t.h3,{id:"key-functions",children:"Key Functions"}),"\n",(0,i.jsxs)(t.table,{children:[(0,i.jsx)(t.thead,{children:(0,i.jsxs)(t.tr,{children:[(0,i.jsx)(t.th,{children:"Function"}),(0,i.jsx)(t.th,{children:"Parameters"}),(0,i.jsx)(t.th,{children:"Description"})]})}),(0,i.jsxs)(t.tbody,{children:[(0,i.jsxs)(t.tr,{children:[(0,i.jsx)(t.td,{children:(0,i.jsx)(t.code,{children:"queryAndRelayStake"})}),(0,i.jsx)(t.td,{children:(0,i.jsx)(t.code,{children:"operator: address"})}),(0,i.jsx)(t.td,{children:"Query a single operator's stake and relay to L2"})]}),(0,i.jsxs)(t.tr,{children:[(0,i.jsx)(t.td,{children:(0,i.jsx)(t.code,{children:"batchQueryStakes"})}),(0,i.jsx)(t.td,{children:(0,i.jsx)(t.code,{children:"operators: address[]"})}),(0,i.jsx)(t.td,{children:"Batch query and relay for multiple operators"})]}),(0,i.jsxs)(t.tr,{children:[(0,i.jsx)(t.td,{children:(0,i.jsx)(t.code,{children:"refreshAllOperators"})}),(0,i.jsx)(t.td,{children:"--"}),(0,i.jsx)(t.td,{children:"Refresh all registered TAL operators (KEEPER_ROLE)"})]}),(0,i.jsxs)(t.tr,{children:[(0,i.jsx)(t.td,{children:(0,i.jsx)(t.code,{children:"registerOperator"})}),(0,i.jsx)(t.td,{children:(0,i.jsx)(t.code,{children:"operator: address"})}),(0,i.jsx)(t.td,{children:"Register an operator for batch refresh"})]}),(0,i.jsxs)(t.tr,{children:[(0,i.jsx)(t.td,{children:(0,i.jsx)(t.code,{children:"removeOperator"})}),(0,i.jsx)(t.td,{children:(0,i.jsx)(t.code,{children:"operator: address"})}),(0,i.jsx)(t.td,{children:"Remove an operator from the registry"})]})]})]}),"\n",(0,i.jsx)(t.h3,{id:"roles",children:"Roles"}),"\n",(0,i.jsxs)(t.table,{children:[(0,i.jsx)(t.thead,{children:(0,i.jsxs)(t.tr,{children:[(0,i.jsx)(t.th,{children:"Role"}),(0,i.jsx)(t.th,{children:"Purpose"})]})}),(0,i.jsxs)(t.tbody,{children:[(0,i.jsxs)(t.tr,{children:[(0,i.jsx)(t.td,{children:(0,i.jsx)(t.code,{children:"DEFAULT_ADMIN_ROLE"})}),(0,i.jsx)(t.td,{children:"Full contract administration"})]}),(0,i.jsxs)(t.tr,{children:[(0,i.jsx)(t.td,{children:(0,i.jsx)(t.code,{children:"UPGRADER_ROLE"})}),(0,i.jsx)(t.td,{children:"Authorize UUPS upgrades"})]}),(0,i.jsxs)(t.tr,{children:[(0,i.jsx)(t.td,{children:(0,i.jsx)(t.code,{children:"PAUSER_ROLE"})}),(0,i.jsx)(t.td,{children:"Emergency pause/unpause"})]}),(0,i.jsxs)(t.tr,{children:[(0,i.jsx)(t.td,{children:(0,i.jsx)(t.code,{children:"KEEPER_ROLE"})}),(0,i.jsxs)(t.td,{children:["Execute ",(0,i.jsx)(t.code,{children:"refreshAllOperators"})," batch updates"]})]})]})]}),"\n",(0,i.jsx)(t.admonition,{title:"Batch Size Limit",type:"info",children:(0,i.jsxs)(t.p,{children:["The ",(0,i.jsx)(t.code,{children:"batchQueryStakes"})," and ",(0,i.jsx)(t.code,{children:"refreshAllOperators"})," functions enforce a maximum batch size of ",(0,i.jsx)(t.strong,{children:"100 operators"})," per call to prevent gas limit issues."]})}),"\n",(0,i.jsx)(t.h2,{id:"l2-bridge-talstakingbridgel2",children:"L2 Bridge: TALStakingBridgeL2"}),"\n",(0,i.jsx)(t.p,{children:"The L2 bridge caches stake snapshots received from L1 and exposes them for TAL registry contracts."}),"\n",(0,i.jsx)(t.h3,{id:"operator-tiers",children:"Operator Tiers"}),"\n",(0,i.jsx)(t.p,{children:"Operators are classified into tiers based on their cached stake amount:"}),"\n",(0,i.jsxs)(t.table,{children:[(0,i.jsx)(t.thead,{children:(0,i.jsxs)(t.tr,{children:[(0,i.jsx)(t.th,{children:"Tier"}),(0,i.jsx)(t.th,{children:"Minimum Stake"}),(0,i.jsx)(t.th,{children:"Description"})]})}),(0,i.jsxs)(t.tbody,{children:[(0,i.jsxs)(t.tr,{children:[(0,i.jsx)(t.td,{children:(0,i.jsx)(t.code,{children:"UNVERIFIED"})}),(0,i.jsx)(t.td,{children:"0 TON"}),(0,i.jsx)(t.td,{children:"No stake or below minimum"})]}),(0,i.jsxs)(t.tr,{children:[(0,i.jsx)(t.td,{children:(0,i.jsx)(t.code,{children:"VERIFIED"})}),(0,i.jsx)(t.td,{children:"1,000 TON"}),(0,i.jsx)(t.td,{children:"Meets minimum operator stake"})]}),(0,i.jsxs)(t.tr,{children:[(0,i.jsx)(t.td,{children:(0,i.jsx)(t.code,{children:"PREMIUM"})}),(0,i.jsx)(t.td,{children:"10,000 TON"}),(0,i.jsx)(t.td,{children:"Premium tier with higher trust"})]})]})]}),"\n",(0,i.jsx)(t.h3,{id:"stakesnapshot-structure",children:"StakeSnapshot Structure"}),"\n",(0,i.jsx)(t.p,{children:"Each operator's cached data includes:"}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{className:"language-solidity",children:"struct StakeSnapshot {\n    uint256 amount;             // Cached stake amount\n    uint256 lastUpdatedL1Block; // L1 block when stake was queried\n    uint256 timestamp;          // L2 timestamp when cache was updated\n}\n"})}),"\n",(0,i.jsx)(t.h3,{id:"cache-freshness",children:"Cache Freshness"}),"\n",(0,i.jsxs)(t.p,{children:["The L2 bridge enforces a default maximum cache age of ",(0,i.jsx)(t.strong,{children:"4 hours"}),". Registries can check the ",(0,i.jsx)(t.code,{children:"timestamp"})," field to determine if the cached data is fresh enough for their use case."]}),"\n",(0,i.jsx)(t.h2,{id:"stakingintegrationmodule",children:"StakingIntegrationModule"}),"\n",(0,i.jsxs)(t.p,{children:["The ",(0,i.jsx)(t.code,{children:"StakingIntegrationModule"})," wraps the L2 bridge for use by TAL registries, adding TAL-specific logic for slashing and seigniorage routing."]}),"\n",(0,i.jsx)(t.h3,{id:"key-functions-1",children:"Key Functions"}),"\n",(0,i.jsxs)(t.table,{children:[(0,i.jsx)(t.thead,{children:(0,i.jsxs)(t.tr,{children:[(0,i.jsx)(t.th,{children:"Function"}),(0,i.jsx)(t.th,{children:"Parameters"}),(0,i.jsx)(t.th,{children:"Returns"}),(0,i.jsx)(t.th,{children:"Description"})]})}),(0,i.jsxs)(t.tbody,{children:[(0,i.jsxs)(t.tr,{children:[(0,i.jsx)(t.td,{children:(0,i.jsx)(t.code,{children:"getStake"})}),(0,i.jsx)(t.td,{children:(0,i.jsx)(t.code,{children:"operator: address"})}),(0,i.jsx)(t.td,{children:(0,i.jsx)(t.code,{children:"uint256"})}),(0,i.jsx)(t.td,{children:"Get operator's cached stake"})]}),(0,i.jsxs)(t.tr,{children:[(0,i.jsx)(t.td,{children:(0,i.jsx)(t.code,{children:"isVerifiedOperator"})}),(0,i.jsx)(t.td,{children:(0,i.jsx)(t.code,{children:"operator: address"})}),(0,i.jsx)(t.td,{children:(0,i.jsx)(t.code,{children:"bool"})}),(0,i.jsx)(t.td,{children:"Check if operator meets minimum stake"})]}),(0,i.jsxs)(t.tr,{children:[(0,i.jsx)(t.td,{children:(0,i.jsx)(t.code,{children:"getOperatorStatus"})}),(0,i.jsx)(t.td,{children:(0,i.jsx)(t.code,{children:"operator: address"})}),(0,i.jsx)(t.td,{children:(0,i.jsx)(t.code,{children:"(uint256, bool, uint256, uint256)"})}),(0,i.jsx)(t.td,{children:"Full status: stake, verified, slash count, last slash time"})]})]})]}),"\n",(0,i.jsx)(t.h3,{id:"slashing-conditions",children:"Slashing Conditions"}),"\n",(0,i.jsx)(t.p,{children:"The module tracks slashing conditions per agent and slash history per operator:"}),"\n",(0,i.jsxs)(t.table,{children:[(0,i.jsx)(t.thead,{children:(0,i.jsxs)(t.tr,{children:[(0,i.jsx)(t.th,{children:"Condition"}),(0,i.jsx)(t.th,{children:"Slash Percentage"})]})}),(0,i.jsxs)(t.tbody,{children:[(0,i.jsxs)(t.tr,{children:[(0,i.jsx)(t.td,{children:"Failed TEE Attestation"}),(0,i.jsx)(t.td,{children:"50%"})]}),(0,i.jsxs)(t.tr,{children:[(0,i.jsx)(t.td,{children:"Proven Fraud"}),(0,i.jsx)(t.td,{children:"100%"})]}),(0,i.jsxs)(t.tr,{children:[(0,i.jsx)(t.td,{children:"Repeated Low Reputation"}),(0,i.jsx)(t.td,{children:"25%"})]})]})]}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{className:"language-solidity",children:"struct OperatorSlashRecord {\n    uint256 totalSlashed;    // Total amount slashed\n    uint256 slashCount;      // Number of slashes\n    uint256 lastSlashTime;   // Timestamp of last slash\n}\n"})}),"\n",(0,i.jsx)(t.h2,{id:"frontend-integration",children:"Frontend Integration"}),"\n",(0,i.jsx)(t.p,{children:"Here is how to check operator stake status from a frontend application:"}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{className:"language-typescript",children:"import { createPublicClient, http, defineChain } from 'viem';\nimport { StakingIntegrationModuleABI } from '@tokamak/tal-sdk';\n\nconst thanosSepolia = defineChain({\n  id: 111551119090,\n  name: 'Thanos Sepolia',\n  nativeCurrency: { name: 'TON', symbol: 'TON', decimals: 18 },\n  rpcUrls: { default: { http: ['https://rpc.thanos-sepolia.tokamak.network'] } },\n});\n\nconst publicClient = createPublicClient({\n  chain: thanosSepolia,\n  transport: http('https://rpc.thanos-sepolia.tokamak.network'),\n});\n\nconst STAKING_MODULE = '0xDc9d9A78676C600E7Ca55a8D0c63da9462Acfe30';\n\n// Check if operator is verified\nconst isVerified = await publicClient.readContract({\n  address: STAKING_MODULE,\n  abi: StakingIntegrationModuleABI,\n  functionName: 'isVerifiedOperator',\n  args: ['0xOperatorAddress'],\n});\n\n// Get full operator status\nconst [stake, verified, slashCount, lastSlash] = await publicClient.readContract({\n  address: STAKING_MODULE,\n  abi: StakingIntegrationModuleABI,\n  functionName: 'getOperatorStatus',\n  args: ['0xOperatorAddress'],\n});\n\nconsole.log(`Stake: ${stake} wei`);\nconsole.log(`Verified: ${verified}`);\nconsole.log(`Slash count: ${slashCount}`);\n"})}),"\n",(0,i.jsx)(t.admonition,{title:"Stale Cache Data",type:"warning",children:(0,i.jsxs)(t.p,{children:["L2 stake data is a ",(0,i.jsx)(t.strong,{children:"cached snapshot"})," of L1 state. There is an inherent delay between L1 staking actions and L2 cache updates. Always check the ",(0,i.jsx)(t.code,{children:"lastUpdatedL1Block"})," field if freshness is critical for your use case."]})}),"\n",(0,i.jsx)(t.h2,{id:"next-steps",children:"Next Steps"}),"\n",(0,i.jsxs)(t.ul,{children:["\n",(0,i.jsxs)(t.li,{children:[(0,i.jsx)(t.a,{href:"./drb-integration",children:"DRB Integration"})," -- How randomness is used for validator selection"]}),"\n",(0,i.jsxs)(t.li,{children:[(0,i.jsx)(t.a,{href:"../sdk/overview",children:"SDK Overview"})," -- Use the TypeScript SDK to query staking data"]}),"\n",(0,i.jsxs)(t.li,{children:[(0,i.jsx)(t.a,{href:"../sdk/reputation-and-validation",children:"Reputation & Validation"})," -- How stake-weighted reputation works"]}),"\n"]})]})}function h(e={}){const{wrapper:t}={...(0,s.R)(),...e.components};return t?(0,i.jsx)(t,{...e,children:(0,i.jsx)(l,{...e})}):l(e)}},8453(e,t,n){n.d(t,{R:()=>a,x:()=>d});var r=n(6540);const i={},s=r.createContext(i);function a(e){const t=r.useContext(s);return r.useMemo(function(){return"function"==typeof e?e(t):{...t,...e}},[t,e])}function d(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(i):e.components||i:a(e.components),r.createElement(s.Provider,{value:t},e.children)}}}]);