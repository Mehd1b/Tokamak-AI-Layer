"use strict";(globalThis.webpackChunktal_docs=globalThis.webpackChunktal_docs||[]).push([[9617],{8375(e,n,t){t.r(n),t.d(n,{assets:()=>c,contentTitle:()=>o,default:()=>p,frontMatter:()=>r,metadata:()=>a,toc:()=>d});const a=JSON.parse('{"id":"app/contract-integration","title":"Contract Integration","description":"The TAL frontend reads and writes to smart contracts using wagmi v2 hooks backed by viem. All contract ABIs are imported from the SDK package, and contract addresses are centralized in a single configuration file.","source":"@site/docs/app/contract-integration.md","sourceDirName":"app","slug":"/app/contract-integration","permalink":"/tal/app/contract-integration","draft":false,"unlisted":false,"editUrl":"https://github.com/tokamak-network/Tokamak-AI-Layer/tree/master/docs/docs/app/contract-integration.md","tags":[],"version":"current","sidebarPosition":5,"frontMatter":{"title":"Contract Integration","sidebar_position":5},"sidebar":"docsSidebar","previous":{"title":"Hooks Reference","permalink":"/tal/app/hooks-reference"},"next":{"title":"Staking Bridge","permalink":"/tal/integration/staking-bridge"}}');var s=t(4848),i=t(8453);const r={title:"Contract Integration",sidebar_position:5},o="Contract Integration",c={},d=[{value:"Contract Addresses",id:"contract-addresses",level:2},{value:"ABI Imports",id:"abi-imports",level:2},{value:"Reading Contract Data",id:"reading-contract-data",level:2},{value:"Single Read",id:"single-read",level:3},{value:"Conditional Reads",id:"conditional-reads",level:3},{value:"Batch Reads (Multicall)",id:"batch-reads-multicall",level:3},{value:"Writing Transactions",id:"writing-transactions",level:2},{value:"Transaction Lifecycle",id:"transaction-lifecycle",level:3},{value:"Write Hook Pattern",id:"write-hook-pattern",level:3},{value:"Parsing Events from Receipts",id:"parsing-events-from-receipts",level:3},{value:"Payable Transactions",id:"payable-transactions",level:3},{value:"Cross-Chain Patterns",id:"cross-chain-patterns",level:2},{value:"Error Handling",id:"error-handling",level:2},{value:"Multi-Step Transaction Flows",id:"multi-step-transaction-flows",level:2}];function l(e){const n={admonition:"admonition",code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",mermaid:"mermaid",p:"p",pre:"pre",strong:"strong",...(0,i.R)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsx)(n.header,{children:(0,s.jsx)(n.h1,{id:"contract-integration",children:"Contract Integration"})}),"\n",(0,s.jsxs)(n.p,{children:["The TAL frontend reads and writes to smart contracts using ",(0,s.jsx)(n.strong,{children:"wagmi v2"})," hooks backed by ",(0,s.jsx)(n.strong,{children:"viem"}),". All contract ABIs are imported from the SDK package, and contract addresses are centralized in a single configuration file."]}),"\n",(0,s.jsx)(n.h2,{id:"contract-addresses",children:"Contract Addresses"}),"\n",(0,s.jsxs)(n.p,{children:["All deployed contract addresses are defined in ",(0,s.jsx)(n.code,{children:"frontend/src/lib/contracts.ts"}),":"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-typescript",children:"import type { Address } from 'viem';\n\n// Thanos Sepolia L2 contracts\nexport const CONTRACTS = {\n  identityRegistry: '0x3f89CD27fD877827E7665A9883b3c0180E22A525' as Address,\n  reputationRegistry: '0x0052258E517835081c94c0B685409f2EfC4D502b' as Address,\n  validationRegistry: '0x09447147C6E75a60A449f38532F06E19F5F632F3' as Address,\n  stakingIntegrationModule: '0xDc9d9A78676C600E7Ca55a8D0c63da9462Acfe30' as Address,\n  taskFeeEscrow: '0x43f9E59b6bFCacD70fcba4f3F6234a6a9F064b8C' as Address,\n} as const;\n\n// L1 Sepolia contracts\nexport const L1_CONTRACTS = {\n  depositManager: '0x90ffcc7F168DceDBEF1Cb6c6eB00cA73F922956F' as Address,\n  seigManager: '0x2320542ae933FbAdf8f5B97cA348c7CeDA90fAd7' as Address,\n  layer2Registry: '0xA0a9576b437E52114aDA8b0BC4149F2F5c604581' as Address,\n  layer2: '0xCBeF7Cc221c04AD2E68e623613cc5d33b0fE1599' as Address,\n  ton: '0xa30fe40285B8f5c0457DbC3B7C8A280373c40044' as Address,\n  wton: '0x79E0d92670106c85E9067b56B8F674340dCa0Bbd' as Address,\n} as const;\n\nexport const CHAIN_ID = 111551119090; // Thanos Sepolia\nexport const L1_CHAIN_ID = 11155111;  // Sepolia\n"})}),"\n",(0,s.jsx)(n.h2,{id:"abi-imports",children:"ABI Imports"}),"\n",(0,s.jsxs)(n.p,{children:["ABIs are imported directly from the SDK source (not a published package). The import path traverses up from ",(0,s.jsx)(n.code,{children:"frontend/src/hooks/"})," to the ",(0,s.jsx)(n.code,{children:"sdk/"})," directory:"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-typescript",children:"// From a hook file in frontend/src/hooks/\nimport { TALIdentityRegistryABI } from '../../../sdk/src/abi/TALIdentityRegistry';\nimport { TALReputationRegistryABI } from '../../../sdk/src/abi/TALReputationRegistry';\nimport { TALValidationRegistryABI } from '../../../sdk/src/abi/TALValidationRegistry';\nimport { TaskFeeEscrowABI } from '../../../sdk/src/abi/TaskFeeEscrow';\n"})}),"\n",(0,s.jsx)(n.admonition,{title:"ABI Source",type:"info",children:(0,s.jsxs)(n.p,{children:["The SDK ABIs in ",(0,s.jsx)(n.code,{children:"sdk/src/abi/"})," are ",(0,s.jsx)(n.strong,{children:"manually maintained"})," TypeScript files, not auto-generated from Foundry's ",(0,s.jsx)(n.code,{children:"forge build"})," output. When contract interfaces change, the ABI files must be updated manually to stay in sync."]})}),"\n",(0,s.jsx)(n.h2,{id:"reading-contract-data",children:"Reading Contract Data"}),"\n",(0,s.jsx)(n.h3,{id:"single-read",children:"Single Read"}),"\n",(0,s.jsxs)(n.p,{children:["Use wagmi's ",(0,s.jsx)(n.code,{children:"useReadContract"})," for individual contract calls:"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-typescript",children:"import { useReadContract } from 'wagmi';\nimport { CONTRACTS } from '@/lib/contracts';\nimport { TALIdentityRegistryABI } from '../../../sdk/src/abi/TALIdentityRegistry';\n\nexport function useAgentCount() {\n  const { data, isLoading } = useReadContract({\n    address: CONTRACTS.identityRegistry,\n    abi: TALIdentityRegistryABI,\n    functionName: 'getAgentCount',\n  });\n\n  return {\n    count: data as bigint | undefined,\n    isLoading,\n  };\n}\n"})}),"\n",(0,s.jsx)(n.h3,{id:"conditional-reads",children:"Conditional Reads"}),"\n",(0,s.jsxs)(n.p,{children:["Pass ",(0,s.jsx)(n.code,{children:"query: { enabled }"})," to defer the call until parameters are available:"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-typescript",children:"export function useAgent(agentId: bigint | undefined) {\n  const enabled = agentId !== undefined;\n\n  const { data: owner } = useReadContract({\n    address: CONTRACTS.identityRegistry,\n    abi: TALIdentityRegistryABI,\n    functionName: 'ownerOf',\n    args: enabled ? [agentId] : undefined,\n    query: { enabled },\n  });\n\n  // ...\n}\n"})}),"\n",(0,s.jsx)(n.h3,{id:"batch-reads-multicall",children:"Batch Reads (Multicall)"}),"\n",(0,s.jsxs)(n.p,{children:["Use ",(0,s.jsx)(n.code,{children:"useReadContracts"})," to batch multiple calls into a single RPC request. This is how the agent list page loads data for up to 50 agents efficiently:"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-typescript",children:"import { useReadContracts } from 'wagmi';\n\nexport function useAgentList(count: number) {\n  const limit = Math.min(count, 50);\n  const contracts = [];\n\n  for (let i = 1; i <= limit; i++) {\n    contracts.push({\n      address: CONTRACTS.identityRegistry,\n      abi: TALIdentityRegistryABI,\n      functionName: 'ownerOf',\n      args: [BigInt(i)],\n    });\n    contracts.push({\n      address: CONTRACTS.identityRegistry,\n      abi: TALIdentityRegistryABI,\n      functionName: 'agentURI',\n      args: [BigInt(i)],\n    });\n  }\n\n  const { data, isLoading } = useReadContracts({\n    contracts: contracts as any,\n    query: { enabled: count > 0 },\n  });\n\n  // Parse pairs of results...\n}\n"})}),"\n",(0,s.jsxs)(n.p,{children:["The ",(0,s.jsx)(n.code,{children:"useAgentRatings"})," hook in ",(0,s.jsx)(n.code,{children:"useReputation.ts"})," demonstrates a two-phase multicall pattern -- first fetching client lists, then conditionally fetching summaries only for agents that have clients."]}),"\n",(0,s.jsx)(n.h2,{id:"writing-transactions",children:"Writing Transactions"}),"\n",(0,s.jsx)(n.h3,{id:"transaction-lifecycle",children:"Transaction Lifecycle"}),"\n",(0,s.jsx)(n.p,{children:"Every write hook follows this pattern:"}),"\n",(0,s.jsx)(n.mermaid,{value:"sequenceDiagram\n    participant C as Component\n    participant WC as useWriteContract\n    participant W as Wallet\n    participant Chain as Blockchain\n    participant TR as useWaitForTransactionReceipt\n\n    C->>WC: writeContract({ address, abi, functionName, args })\n    WC->>W: Prompt user to sign\n    Note over WC: isPending = true\n    W->>Chain: Submit signed transaction\n    W->>WC: Return tx hash\n    WC->>TR: Watch for receipt\n    Note over TR: isConfirming = true\n    Chain->>TR: Transaction mined\n    Note over TR: isSuccess = true\n    TR->>C: Receipt available"}),"\n",(0,s.jsx)(n.h3,{id:"write-hook-pattern",children:"Write Hook Pattern"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-typescript",children:"import { useWriteContract, useWaitForTransactionReceipt } from 'wagmi';\n\nexport function useRegisterAgent() {\n  const { writeContract, data: hash, isPending, error } = useWriteContract();\n  const { data: receipt, isLoading: isConfirming, isSuccess } =\n    useWaitForTransactionReceipt({ hash });\n\n  const register = (agentURI: string) => {\n    writeContract({\n      address: CONTRACTS.identityRegistry,\n      abi: TALIdentityRegistryABI,\n      functionName: 'register',\n      args: [agentURI],\n      chainId: CHAIN_ID,\n    });\n  };\n\n  return { register, hash, isPending, isConfirming, isSuccess, error };\n}\n"})}),"\n",(0,s.jsx)(n.h3,{id:"parsing-events-from-receipts",children:"Parsing Events from Receipts"}),"\n",(0,s.jsx)(n.p,{children:"After a transaction is confirmed, you can parse emitted events from the receipt logs:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-typescript",children:"// Parse new agent ID from ERC-721 Transfer event\nconst TRANSFER_TOPIC =\n  '0xddf252ad1be2c89b69c2b068fc378daa952ba7f163c4a11628f55a4df523b3ef';\n\nlet newAgentId: bigint | undefined;\nif (receipt?.logs) {\n  const transferLog = receipt.logs.find(\n    (log) =>\n      log.address.toLowerCase() ===\n        CONTRACTS.identityRegistry.toLowerCase() &&\n      log.topics[0] === TRANSFER_TOPIC,\n  );\n  if (transferLog?.topics[3]) {\n    newAgentId = BigInt(transferLog.topics[3]);\n  }\n}\n"})}),"\n",(0,s.jsx)(n.h3,{id:"payable-transactions",children:"Payable Transactions"}),"\n",(0,s.jsxs)(n.p,{children:["For functions that accept ETH/TON value, pass the ",(0,s.jsx)(n.code,{children:"value"})," field:"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-typescript",children:"const requestValidation = (params: RequestValidationOnChainParams) => {\n  writeContract({\n    address: CONTRACTS.validationRegistry,\n    abi: TALValidationRegistryABI,\n    functionName: 'requestValidation',\n    args: [\n      params.agentId,\n      params.taskHash,\n      params.outputHash,\n      params.model,\n      params.deadline,\n    ],\n    value: params.bountyWei, // Native TON sent as bounty\n    chainId: CHAIN_ID,\n  });\n};\n"})}),"\n",(0,s.jsx)(n.h2,{id:"cross-chain-patterns",children:"Cross-Chain Patterns"}),"\n",(0,s.jsxs)(n.p,{children:["The staking hooks demonstrate cross-chain contract interaction by specifying ",(0,s.jsx)(n.code,{children:"chainId: sepolia.id"})," for L1 operations:"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-typescript",children:"export function useTONBalance(address?: Address) {\n  return useReadContract({\n    address: L1_CONTRACTS.ton,\n    abi: ERC20_ABI,\n    functionName: 'balanceOf',\n    args: address ? [address] : undefined,\n    chainId: sepolia.id, // Force L1 Sepolia\n    query: { enabled: !!address },\n  });\n}\n"})}),"\n",(0,s.jsxs)(n.p,{children:["This allows the staking page to read L1 balances even when the user's wallet is connected to L2, since wagmi's ",(0,s.jsx)(n.code,{children:"useReadContract"})," can specify any configured chain."]}),"\n",(0,s.jsx)(n.h2,{id:"error-handling",children:"Error Handling"}),"\n",(0,s.jsxs)(n.p,{children:["Each write hook exposes an ",(0,s.jsx)(n.code,{children:"error"})," field from ",(0,s.jsx)(n.code,{children:"useWriteContract"}),". Components display these errors alongside status messages:"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-tsx",children:'{txError && (\n  <div className="error-banner">\n    <strong>Transaction Error:</strong> {txError.message}\n  </div>\n)}\n\n{isSuccess && txHash && (\n  <div className="success-banner">\n    <strong>Success!</strong> Transaction:{\' \'}\n    <a href={`https://explorer.thanos-sepolia.tokamak.network/tx/${txHash}`}>\n      {txHash.slice(0, 10)}...{txHash.slice(-8)}\n    </a>\n  </div>\n)}\n'})}),"\n",(0,s.jsx)(n.h2,{id:"multi-step-transaction-flows",children:"Multi-Step Transaction Flows"}),"\n",(0,s.jsx)(n.p,{children:"The staking page implements a multi-step flow where each step must complete before the next can execute:"}),"\n",(0,s.jsx)(n.mermaid,{value:"graph LR\n    A[Approve TON] --\x3e|allowance >= amount| B[Swap TON to WTON]\n    B --\x3e|WTON balance >= amount| C[Approve WTON]\n    C --\x3e|allowance >= amount| D[Deposit to Staking]\n\n    style A fill:#1e3a5f\n    style B fill:#1e3a5f\n    style C fill:#1e3a5f\n    style D fill:#1e3a5f"}),"\n",(0,s.jsx)(n.p,{children:"The page detects which step is needed by checking allowances and balances, then calls the appropriate write function. A step progress indicator shows the user which step they are on."})]})}function p(e={}){const{wrapper:n}={...(0,i.R)(),...e.components};return n?(0,s.jsx)(n,{...e,children:(0,s.jsx)(l,{...e})}):l(e)}},8453(e,n,t){t.d(n,{R:()=>r,x:()=>o});var a=t(6540);const s={},i=a.createContext(s);function r(e){const n=a.useContext(i);return a.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function o(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(s):e.components||s:r(e.components),a.createElement(i.Provider,{value:n},e.children)}}}]);