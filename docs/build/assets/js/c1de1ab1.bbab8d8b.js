"use strict";(globalThis.webpackChunktal_docs=globalThis.webpackChunktal_docs||[]).push([[2739],{7644(e,t,n){n.r(t),n.d(t,{assets:()=>a,contentTitle:()=>c,default:()=>o,frontMatter:()=>s,metadata:()=>i,toc:()=>l});const i=JSON.parse('{"id":"contracts/identity-registry","title":"Identity Registry","description":"The TALIdentityRegistry is the core identity layer of the Tokamak AI Layer. It implements the ERC-8004 standard for trustless AI agent identities, representing each agent as an ERC-721 NFT with associated metadata, ZK identity commitments, and operator management capabilities.","source":"@site/docs/contracts/identity-registry.md","sourceDirName":"contracts","slug":"/contracts/identity-registry","permalink":"/tal/contracts/identity-registry","draft":false,"unlisted":false,"editUrl":"https://github.com/tokamak-network/Tokamak-AI-Layer/tree/master/docs/docs/contracts/identity-registry.md","tags":[],"version":"current","sidebarPosition":1,"frontMatter":{"title":"Identity Registry","sidebar_position":1},"sidebar":"docsSidebar","previous":{"title":"Cross-Layer Bridge","permalink":"/tal/architecture/cross-layer-bridge"},"next":{"title":"Reputation Registry","permalink":"/tal/contracts/reputation-registry"}}');var d=n(4848),r=n(8453);const s={title:"Identity Registry",sidebar_position:1},c="Identity Registry",a={},l=[{value:"Overview",id:"overview",level:2},{value:"Key Features",id:"key-features",level:3},{value:"Architecture",id:"architecture",level:2},{value:"Function Reference",id:"function-reference",level:2},{value:"Registration",id:"registration",level:3},{value:"Metadata Management",id:"metadata-management",level:3},{value:"ZK Identity",id:"zk-identity",level:3},{value:"Capability Verification",id:"capability-verification",level:3},{value:"Operator Management",id:"operator-management",level:3},{value:"Wallet Verification",id:"wallet-verification",level:3},{value:"Query Functions",id:"query-functions",level:3},{value:"Admin Functions",id:"admin-functions",level:3},{value:"Events",id:"events",level:2},{value:"Access Control Roles",id:"access-control-roles",level:2},{value:"Constants",id:"constants",level:2},{value:"Code Example: Registering an Agent",id:"code-example-registering-an-agent",level:2},{value:"Related Pages",id:"related-pages",level:2}];function h(e){const t={a:"a",admonition:"admonition",code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",li:"li",mermaid:"mermaid",p:"p",pre:"pre",strong:"strong",table:"table",tbody:"tbody",td:"td",th:"th",thead:"thead",tr:"tr",ul:"ul",...(0,r.R)(),...e.components};return(0,d.jsxs)(d.Fragment,{children:[(0,d.jsx)(t.header,{children:(0,d.jsx)(t.h1,{id:"identity-registry",children:"Identity Registry"})}),"\n",(0,d.jsxs)(t.p,{children:["The ",(0,d.jsx)(t.strong,{children:"TALIdentityRegistry"})," is the core identity layer of the Tokamak AI Layer. It implements the ERC-8004 standard for trustless AI agent identities, representing each agent as an ERC-721 NFT with associated metadata, ZK identity commitments, and operator management capabilities."]}),"\n",(0,d.jsx)(t.h2,{id:"overview",children:"Overview"}),"\n",(0,d.jsx)(t.p,{children:"Every agent in the TAL ecosystem starts here. Registration mints a soulbound-style NFT that serves as the agent's on-chain identity, linking it to an IPFS metadata URI, optional zero-knowledge commitments, and a designated operator address backed by staked TON."}),"\n",(0,d.jsx)(t.h3,{id:"key-features",children:"Key Features"}),"\n",(0,d.jsxs)(t.ul,{children:["\n",(0,d.jsxs)(t.li,{children:[(0,d.jsx)(t.strong,{children:"ERC-721 Agent NFTs"})," -- each registered agent receives a unique token ID starting from 1"]}),"\n",(0,d.jsxs)(t.li,{children:[(0,d.jsx)(t.strong,{children:"ZK Identity Commitments"})," -- Poseidon hash commitments for privacy-preserving identity verification"]}),"\n",(0,d.jsxs)(t.li,{children:[(0,d.jsx)(t.strong,{children:"Capability Verification"})," -- SNARK proof-based capability attestation against the agent's ZK identity"]}),"\n",(0,d.jsxs)(t.li,{children:[(0,d.jsx)(t.strong,{children:"Operator Management"})," -- stake-verified operator addresses via the cross-layer bridge to L1 Staking V3"]}),"\n",(0,d.jsxs)(t.li,{children:[(0,d.jsx)(t.strong,{children:"EIP-712 Wallet Verification"})," -- signature-based proof of wallet ownership with replay protection"]}),"\n",(0,d.jsxs)(t.li,{children:[(0,d.jsx)(t.strong,{children:"UUPS Upgradeability"})," -- proxy pattern for future improvements without redeployment"]}),"\n"]}),"\n",(0,d.jsx)(t.admonition,{title:"Where in the code?",type:"tip",children:(0,d.jsxs)(t.p,{children:[(0,d.jsx)(t.strong,{children:"Contract"}),": ",(0,d.jsx)(t.a,{href:"https://github.com/nicejudy/Tokamak-AI-Layer/blob/master/contracts/src/core/TALIdentityRegistry.sol",children:(0,d.jsx)(t.code,{children:"contracts/src/core/TALIdentityRegistry.sol"})})," (602 lines)\n",(0,d.jsx)(t.strong,{children:"Interface"}),": ",(0,d.jsx)(t.a,{href:"https://github.com/nicejudy/Tokamak-AI-Layer/blob/master/contracts/src/interfaces/ITALIdentityRegistry.sol",children:(0,d.jsx)(t.code,{children:"contracts/src/interfaces/ITALIdentityRegistry.sol"})}),"\n",(0,d.jsx)(t.strong,{children:"SDK Client"}),": ",(0,d.jsx)(t.code,{children:"sdk/src/identity/IdentityClient.ts"})]})}),"\n",(0,d.jsx)(t.h2,{id:"architecture",children:"Architecture"}),"\n",(0,d.jsx)(t.mermaid,{value:"graph TD\n    A[Agent Owner] --\x3e|register / registerWithZKIdentity| B[TALIdentityRegistry]\n    B --\x3e|Mints ERC-721| C[Agent NFT #ID]\n    B --\x3e|Stores| D[Agent URI - IPFS]\n    B --\x3e|Stores| E[ZK Commitment - Poseidon Hash]\n    B --\x3e|setOperator| F[Operator Address]\n    F --\x3e|getStake via bridge| G[TALStakingBridgeL2]\n    G --\x3e|Cached from L1| H[Staking V3 on Ethereum]\n    I[ZK Verifier Module] --\x3e|verifyCapabilityProof| B"}),"\n",(0,d.jsx)(t.h2,{id:"function-reference",children:"Function Reference"}),"\n",(0,d.jsx)(t.h3,{id:"registration",children:"Registration"}),"\n",(0,d.jsxs)(t.table,{children:[(0,d.jsx)(t.thead,{children:(0,d.jsxs)(t.tr,{children:[(0,d.jsx)(t.th,{children:"Function"}),(0,d.jsx)(t.th,{children:"Parameters"}),(0,d.jsx)(t.th,{children:"Returns"}),(0,d.jsx)(t.th,{children:"Description"})]})}),(0,d.jsxs)(t.tbody,{children:[(0,d.jsxs)(t.tr,{children:[(0,d.jsx)(t.td,{children:(0,d.jsx)(t.code,{children:"register"})}),(0,d.jsx)(t.td,{children:(0,d.jsx)(t.code,{children:"string agentURI"})}),(0,d.jsx)(t.td,{children:(0,d.jsx)(t.code,{children:"uint256 agentId"})}),(0,d.jsx)(t.td,{children:"Mint a new agent identity NFT. The URI typically points to an IPFS JSON file containing the agent's registration metadata."})]}),(0,d.jsxs)(t.tr,{children:[(0,d.jsx)(t.td,{children:(0,d.jsx)(t.code,{children:"registerWithZKIdentity"})}),(0,d.jsx)(t.td,{children:(0,d.jsx)(t.code,{children:"string agentURI, bytes32 zkCommitment"})}),(0,d.jsx)(t.td,{children:(0,d.jsx)(t.code,{children:"uint256 agentId"})}),(0,d.jsxs)(t.td,{children:["Register with a ZK identity commitment in a single transaction. More gas-efficient than calling ",(0,d.jsx)(t.code,{children:"register"})," + ",(0,d.jsx)(t.code,{children:"setZKIdentity"})," separately."]})]})]})]}),"\n",(0,d.jsx)(t.h3,{id:"metadata-management",children:"Metadata Management"}),"\n",(0,d.jsxs)(t.table,{children:[(0,d.jsx)(t.thead,{children:(0,d.jsxs)(t.tr,{children:[(0,d.jsx)(t.th,{children:"Function"}),(0,d.jsx)(t.th,{children:"Parameters"}),(0,d.jsx)(t.th,{children:"Returns"}),(0,d.jsx)(t.th,{children:"Description"})]})}),(0,d.jsxs)(t.tbody,{children:[(0,d.jsxs)(t.tr,{children:[(0,d.jsx)(t.td,{children:(0,d.jsx)(t.code,{children:"updateAgentURI"})}),(0,d.jsx)(t.td,{children:(0,d.jsx)(t.code,{children:"uint256 agentId, string newURI"})}),(0,d.jsx)(t.td,{children:"--"}),(0,d.jsx)(t.td,{children:"Update the agent's metadata URI. Owner only."})]}),(0,d.jsxs)(t.tr,{children:[(0,d.jsx)(t.td,{children:(0,d.jsx)(t.code,{children:"agentURI"})}),(0,d.jsx)(t.td,{children:(0,d.jsx)(t.code,{children:"uint256 agentId"})}),(0,d.jsx)(t.td,{children:(0,d.jsx)(t.code,{children:"string"})}),(0,d.jsx)(t.td,{children:"Retrieve the agent's current metadata URI."})]}),(0,d.jsxs)(t.tr,{children:[(0,d.jsx)(t.td,{children:(0,d.jsx)(t.code,{children:"setMetadata"})}),(0,d.jsx)(t.td,{children:(0,d.jsx)(t.code,{children:"uint256 agentId, string key, bytes value"})}),(0,d.jsx)(t.td,{children:"--"}),(0,d.jsx)(t.td,{children:"Store arbitrary key-value metadata. Owner only."})]}),(0,d.jsxs)(t.tr,{children:[(0,d.jsx)(t.td,{children:(0,d.jsx)(t.code,{children:"getMetadata"})}),(0,d.jsx)(t.td,{children:(0,d.jsx)(t.code,{children:"uint256 agentId, string key"})}),(0,d.jsx)(t.td,{children:(0,d.jsx)(t.code,{children:"bytes"})}),(0,d.jsx)(t.td,{children:"Retrieve raw bytes for a metadata key."})]})]})]}),"\n",(0,d.jsx)(t.h3,{id:"zk-identity",children:"ZK Identity"}),"\n",(0,d.jsxs)(t.table,{children:[(0,d.jsx)(t.thead,{children:(0,d.jsxs)(t.tr,{children:[(0,d.jsx)(t.th,{children:"Function"}),(0,d.jsx)(t.th,{children:"Parameters"}),(0,d.jsx)(t.th,{children:"Returns"}),(0,d.jsx)(t.th,{children:"Description"})]})}),(0,d.jsxs)(t.tbody,{children:[(0,d.jsxs)(t.tr,{children:[(0,d.jsx)(t.td,{children:(0,d.jsx)(t.code,{children:"setZKIdentity"})}),(0,d.jsx)(t.td,{children:(0,d.jsx)(t.code,{children:"uint256 agentId, bytes32 zkCommitment"})}),(0,d.jsx)(t.td,{children:"--"}),(0,d.jsx)(t.td,{children:"Set the ZK identity commitment. Can only be set once per agent (immutable after creation). Owner only."})]}),(0,d.jsxs)(t.tr,{children:[(0,d.jsx)(t.td,{children:(0,d.jsx)(t.code,{children:"getZKIdentity"})}),(0,d.jsx)(t.td,{children:(0,d.jsx)(t.code,{children:"uint256 agentId"})}),(0,d.jsx)(t.td,{children:(0,d.jsx)(t.code,{children:"bytes32"})}),(0,d.jsxs)(t.td,{children:["Retrieve the agent's ZK commitment. Returns ",(0,d.jsx)(t.code,{children:"bytes32(0)"})," if not set."]})]})]})]}),"\n",(0,d.jsx)(t.h3,{id:"capability-verification",children:"Capability Verification"}),"\n",(0,d.jsxs)(t.table,{children:[(0,d.jsx)(t.thead,{children:(0,d.jsxs)(t.tr,{children:[(0,d.jsx)(t.th,{children:"Function"}),(0,d.jsx)(t.th,{children:"Parameters"}),(0,d.jsx)(t.th,{children:"Returns"}),(0,d.jsx)(t.th,{children:"Description"})]})}),(0,d.jsxs)(t.tbody,{children:[(0,d.jsxs)(t.tr,{children:[(0,d.jsx)(t.td,{children:(0,d.jsx)(t.code,{children:"verifyCapability"})}),(0,d.jsx)(t.td,{children:(0,d.jsx)(t.code,{children:"uint256 agentId, bytes32 capabilityHash, bytes zkProof"})}),(0,d.jsx)(t.td,{children:(0,d.jsx)(t.code,{children:"bool"})}),(0,d.jsx)(t.td,{children:"Verify a capability claim via ZK proof against the agent's identity commitment. Requires a ZK identity to be set."})]}),(0,d.jsxs)(t.tr,{children:[(0,d.jsx)(t.td,{children:(0,d.jsx)(t.code,{children:"isCapabilityVerified"})}),(0,d.jsx)(t.td,{children:(0,d.jsx)(t.code,{children:"uint256 agentId, bytes32 capabilityHash"})}),(0,d.jsx)(t.td,{children:(0,d.jsx)(t.code,{children:"bool"})}),(0,d.jsx)(t.td,{children:"Check if a capability has been verified."})]}),(0,d.jsxs)(t.tr,{children:[(0,d.jsx)(t.td,{children:(0,d.jsx)(t.code,{children:"getVerifiedCapabilities"})}),(0,d.jsx)(t.td,{children:(0,d.jsx)(t.code,{children:"uint256 agentId"})}),(0,d.jsx)(t.td,{children:(0,d.jsx)(t.code,{children:"bytes32[]"})}),(0,d.jsx)(t.td,{children:"List all verified capability hashes for an agent."})]})]})]}),"\n",(0,d.jsx)(t.h3,{id:"operator-management",children:"Operator Management"}),"\n",(0,d.jsxs)(t.table,{children:[(0,d.jsx)(t.thead,{children:(0,d.jsxs)(t.tr,{children:[(0,d.jsx)(t.th,{children:"Function"}),(0,d.jsx)(t.th,{children:"Parameters"}),(0,d.jsx)(t.th,{children:"Returns"}),(0,d.jsx)(t.th,{children:"Description"})]})}),(0,d.jsxs)(t.tbody,{children:[(0,d.jsxs)(t.tr,{children:[(0,d.jsx)(t.td,{children:(0,d.jsx)(t.code,{children:"setOperator"})}),(0,d.jsx)(t.td,{children:(0,d.jsx)(t.code,{children:"uint256 agentId, address operator"})}),(0,d.jsx)(t.td,{children:"--"}),(0,d.jsx)(t.td,{children:"Assign an operator and automatically refresh stake verification. Owner only."})]}),(0,d.jsxs)(t.tr,{children:[(0,d.jsx)(t.td,{children:(0,d.jsx)(t.code,{children:"getOperator"})}),(0,d.jsx)(t.td,{children:(0,d.jsx)(t.code,{children:"uint256 agentId"})}),(0,d.jsx)(t.td,{children:(0,d.jsx)(t.code,{children:"address"})}),(0,d.jsxs)(t.td,{children:["Get the current operator address. Returns ",(0,d.jsx)(t.code,{children:"address(0)"})," if not set."]})]}),(0,d.jsxs)(t.tr,{children:[(0,d.jsx)(t.td,{children:(0,d.jsx)(t.code,{children:"checkOperatorStatus"})}),(0,d.jsx)(t.td,{children:(0,d.jsx)(t.code,{children:"uint256 agentId"})}),(0,d.jsx)(t.td,{children:(0,d.jsx)(t.code,{children:"bool"})}),(0,d.jsx)(t.td,{children:"Check cached operator verification status."})]}),(0,d.jsxs)(t.tr,{children:[(0,d.jsx)(t.td,{children:(0,d.jsx)(t.code,{children:"refreshOperatorStatus"})}),(0,d.jsx)(t.td,{children:(0,d.jsx)(t.code,{children:"uint256 agentId"})}),(0,d.jsx)(t.td,{children:"--"}),(0,d.jsx)(t.td,{children:"Re-query the staking bridge and update cached verification status."})]}),(0,d.jsxs)(t.tr,{children:[(0,d.jsx)(t.td,{children:(0,d.jsx)(t.code,{children:"isVerifiedOperator"})}),(0,d.jsx)(t.td,{children:(0,d.jsx)(t.code,{children:"uint256 agentId"})}),(0,d.jsx)(t.td,{children:(0,d.jsx)(t.code,{children:"bool"})}),(0,d.jsxs)(t.td,{children:["Alias for ",(0,d.jsx)(t.code,{children:"checkOperatorStatus"}),"."]})]})]})]}),"\n",(0,d.jsx)(t.h3,{id:"wallet-verification",children:"Wallet Verification"}),"\n",(0,d.jsxs)(t.table,{children:[(0,d.jsx)(t.thead,{children:(0,d.jsxs)(t.tr,{children:[(0,d.jsx)(t.th,{children:"Function"}),(0,d.jsx)(t.th,{children:"Parameters"}),(0,d.jsx)(t.th,{children:"Returns"}),(0,d.jsx)(t.th,{children:"Description"})]})}),(0,d.jsxs)(t.tbody,{children:[(0,d.jsxs)(t.tr,{children:[(0,d.jsx)(t.td,{children:(0,d.jsx)(t.code,{children:"verifyAgentWallet"})}),(0,d.jsx)(t.td,{children:(0,d.jsx)(t.code,{children:"uint256 agentId, address wallet, bytes signature"})}),(0,d.jsx)(t.td,{children:"--"}),(0,d.jsx)(t.td,{children:"Verify wallet ownership using EIP-712 typed data signatures. Nonces prevent replay attacks. Owner only."})]}),(0,d.jsxs)(t.tr,{children:[(0,d.jsx)(t.td,{children:(0,d.jsx)(t.code,{children:"isVerifiedWallet"})}),(0,d.jsx)(t.td,{children:(0,d.jsx)(t.code,{children:"uint256 agentId, address wallet"})}),(0,d.jsx)(t.td,{children:(0,d.jsx)(t.code,{children:"bool"})}),(0,d.jsx)(t.td,{children:"Check if a wallet is verified for the agent."})]})]})]}),"\n",(0,d.jsx)(t.h3,{id:"query-functions",children:"Query Functions"}),"\n",(0,d.jsxs)(t.table,{children:[(0,d.jsx)(t.thead,{children:(0,d.jsxs)(t.tr,{children:[(0,d.jsx)(t.th,{children:"Function"}),(0,d.jsx)(t.th,{children:"Parameters"}),(0,d.jsx)(t.th,{children:"Returns"}),(0,d.jsx)(t.th,{children:"Description"})]})}),(0,d.jsxs)(t.tbody,{children:[(0,d.jsxs)(t.tr,{children:[(0,d.jsx)(t.td,{children:(0,d.jsx)(t.code,{children:"getAgentCount"})}),(0,d.jsx)(t.td,{children:"--"}),(0,d.jsx)(t.td,{children:(0,d.jsx)(t.code,{children:"uint256"})}),(0,d.jsx)(t.td,{children:"Total number of registered agents."})]}),(0,d.jsxs)(t.tr,{children:[(0,d.jsx)(t.td,{children:(0,d.jsx)(t.code,{children:"getAgentsByOwner"})}),(0,d.jsx)(t.td,{children:(0,d.jsx)(t.code,{children:"address owner"})}),(0,d.jsx)(t.td,{children:(0,d.jsx)(t.code,{children:"uint256[]"})}),(0,d.jsx)(t.td,{children:"All agent IDs owned by an address."})]}),(0,d.jsxs)(t.tr,{children:[(0,d.jsx)(t.td,{children:(0,d.jsx)(t.code,{children:"agentExists"})}),(0,d.jsx)(t.td,{children:(0,d.jsx)(t.code,{children:"uint256 agentId"})}),(0,d.jsx)(t.td,{children:(0,d.jsx)(t.code,{children:"bool"})}),(0,d.jsx)(t.td,{children:"Check if an agent has been registered."})]})]})]}),"\n",(0,d.jsx)(t.h3,{id:"admin-functions",children:"Admin Functions"}),"\n",(0,d.jsxs)(t.table,{children:[(0,d.jsx)(t.thead,{children:(0,d.jsxs)(t.tr,{children:[(0,d.jsx)(t.th,{children:"Function"}),(0,d.jsx)(t.th,{children:"Parameters"}),(0,d.jsx)(t.th,{children:"Access"}),(0,d.jsx)(t.th,{children:"Description"})]})}),(0,d.jsxs)(t.tbody,{children:[(0,d.jsxs)(t.tr,{children:[(0,d.jsx)(t.td,{children:(0,d.jsx)(t.code,{children:"pause"})}),(0,d.jsx)(t.td,{children:"--"}),(0,d.jsx)(t.td,{children:(0,d.jsx)(t.code,{children:"PAUSER_ROLE"})}),(0,d.jsx)(t.td,{children:"Pause registrations and transfers."})]}),(0,d.jsxs)(t.tr,{children:[(0,d.jsx)(t.td,{children:(0,d.jsx)(t.code,{children:"unpause"})}),(0,d.jsx)(t.td,{children:"--"}),(0,d.jsx)(t.td,{children:(0,d.jsx)(t.code,{children:"PAUSER_ROLE"})}),(0,d.jsx)(t.td,{children:"Resume normal operations."})]}),(0,d.jsxs)(t.tr,{children:[(0,d.jsx)(t.td,{children:(0,d.jsx)(t.code,{children:"setStakingBridge"})}),(0,d.jsx)(t.td,{children:(0,d.jsx)(t.code,{children:"address _stakingBridge"})}),(0,d.jsx)(t.td,{children:(0,d.jsx)(t.code,{children:"DEFAULT_ADMIN_ROLE"})}),(0,d.jsx)(t.td,{children:"Update the staking bridge address."})]}),(0,d.jsxs)(t.tr,{children:[(0,d.jsx)(t.td,{children:(0,d.jsx)(t.code,{children:"setZKVerifier"})}),(0,d.jsx)(t.td,{children:(0,d.jsx)(t.code,{children:"address _zkVerifier"})}),(0,d.jsx)(t.td,{children:(0,d.jsx)(t.code,{children:"DEFAULT_ADMIN_ROLE"})}),(0,d.jsx)(t.td,{children:"Update the ZK verifier module address."})]})]})]}),"\n",(0,d.jsx)(t.h2,{id:"events",children:"Events"}),"\n",(0,d.jsxs)(t.table,{children:[(0,d.jsx)(t.thead,{children:(0,d.jsxs)(t.tr,{children:[(0,d.jsx)(t.th,{children:"Event"}),(0,d.jsx)(t.th,{children:"Parameters"}),(0,d.jsx)(t.th,{children:"Description"})]})}),(0,d.jsxs)(t.tbody,{children:[(0,d.jsxs)(t.tr,{children:[(0,d.jsx)(t.td,{children:(0,d.jsx)(t.code,{children:"Registered"})}),(0,d.jsx)(t.td,{children:(0,d.jsx)(t.code,{children:"uint256 indexed agentId, address indexed owner, string agentURI"})}),(0,d.jsx)(t.td,{children:"Emitted when a new agent is registered."})]}),(0,d.jsxs)(t.tr,{children:[(0,d.jsx)(t.td,{children:(0,d.jsx)(t.code,{children:"AgentURIUpdated"})}),(0,d.jsx)(t.td,{children:(0,d.jsx)(t.code,{children:"uint256 indexed agentId, string newURI"})}),(0,d.jsx)(t.td,{children:"Emitted when an agent's URI is updated."})]}),(0,d.jsxs)(t.tr,{children:[(0,d.jsx)(t.td,{children:(0,d.jsx)(t.code,{children:"MetadataUpdated"})}),(0,d.jsx)(t.td,{children:(0,d.jsx)(t.code,{children:"uint256 indexed agentId, string key"})}),(0,d.jsx)(t.td,{children:"Emitted when agent metadata is changed."})]}),(0,d.jsxs)(t.tr,{children:[(0,d.jsx)(t.td,{children:(0,d.jsx)(t.code,{children:"AgentWalletVerified"})}),(0,d.jsx)(t.td,{children:(0,d.jsx)(t.code,{children:"uint256 indexed agentId, address wallet"})}),(0,d.jsx)(t.td,{children:"Emitted when a wallet is verified for an agent."})]}),(0,d.jsxs)(t.tr,{children:[(0,d.jsx)(t.td,{children:(0,d.jsx)(t.code,{children:"ZKIdentitySet"})}),(0,d.jsx)(t.td,{children:(0,d.jsx)(t.code,{children:"uint256 indexed agentId, bytes32 zkCommitment"})}),(0,d.jsx)(t.td,{children:"Emitted when a ZK identity commitment is set."})]}),(0,d.jsxs)(t.tr,{children:[(0,d.jsx)(t.td,{children:(0,d.jsx)(t.code,{children:"CapabilityVerified"})}),(0,d.jsx)(t.td,{children:(0,d.jsx)(t.code,{children:"uint256 indexed agentId, bytes32 indexed capabilityHash"})}),(0,d.jsx)(t.td,{children:"Emitted when a capability is verified via ZK proof."})]}),(0,d.jsxs)(t.tr,{children:[(0,d.jsx)(t.td,{children:(0,d.jsx)(t.code,{children:"OperatorSet"})}),(0,d.jsx)(t.td,{children:(0,d.jsx)(t.code,{children:"uint256 indexed agentId, address indexed operator"})}),(0,d.jsx)(t.td,{children:"Emitted when an operator is assigned."})]}),(0,d.jsxs)(t.tr,{children:[(0,d.jsx)(t.td,{children:(0,d.jsx)(t.code,{children:"OperatorStatusChanged"})}),(0,d.jsx)(t.td,{children:(0,d.jsx)(t.code,{children:"uint256 indexed agentId, bool isVerified, uint256 stakeAmount"})}),(0,d.jsx)(t.td,{children:"Emitted when operator verification status changes."})]})]})]}),"\n",(0,d.jsx)(t.h2,{id:"access-control-roles",children:"Access Control Roles"}),"\n",(0,d.jsxs)(t.table,{children:[(0,d.jsx)(t.thead,{children:(0,d.jsxs)(t.tr,{children:[(0,d.jsx)(t.th,{children:"Role"}),(0,d.jsx)(t.th,{children:"Purpose"})]})}),(0,d.jsxs)(t.tbody,{children:[(0,d.jsxs)(t.tr,{children:[(0,d.jsx)(t.td,{children:(0,d.jsx)(t.code,{children:"DEFAULT_ADMIN_ROLE"})}),(0,d.jsx)(t.td,{children:"Full admin access: manage roles, update bridge and verifier addresses"})]}),(0,d.jsxs)(t.tr,{children:[(0,d.jsx)(t.td,{children:(0,d.jsx)(t.code,{children:"UPGRADER_ROLE"})}),(0,d.jsx)(t.td,{children:"Authorize UUPS proxy upgrades"})]}),(0,d.jsxs)(t.tr,{children:[(0,d.jsx)(t.td,{children:(0,d.jsx)(t.code,{children:"PAUSER_ROLE"})}),(0,d.jsx)(t.td,{children:"Pause and unpause the contract"})]})]})]}),"\n",(0,d.jsx)(t.h2,{id:"constants",children:"Constants"}),"\n",(0,d.jsxs)(t.table,{children:[(0,d.jsx)(t.thead,{children:(0,d.jsxs)(t.tr,{children:[(0,d.jsx)(t.th,{children:"Constant"}),(0,d.jsx)(t.th,{children:"Value"}),(0,d.jsx)(t.th,{children:"Description"})]})}),(0,d.jsx)(t.tbody,{children:(0,d.jsxs)(t.tr,{children:[(0,d.jsx)(t.td,{children:(0,d.jsx)(t.code,{children:"MIN_OPERATOR_STAKE"})}),(0,d.jsxs)(t.td,{children:[(0,d.jsx)(t.code,{children:"1000 ether"})," (1000 TON)"]}),(0,d.jsx)(t.td,{children:"Minimum L1 stake required for operator verification"})]})})]}),"\n",(0,d.jsx)(t.h2,{id:"code-example-registering-an-agent",children:"Code Example: Registering an Agent"}),"\n",(0,d.jsx)(t.pre,{children:(0,d.jsx)(t.code,{className:"language-solidity",children:'// Register a basic agent\nuint256 agentId = identityRegistry.register("ipfs://QmYourAgentMetadata...");\n\n// Register with ZK identity in a single transaction\nbytes32 zkCommitment = keccak256(abi.encodePacked(agentSecret, agentSalt));\nuint256 agentId = identityRegistry.registerWithZKIdentity(\n    "ipfs://QmYourAgentMetadata...",\n    zkCommitment\n);\n\n// Set an operator for the agent\nidentityRegistry.setOperator(agentId, operatorAddress);\n\n// Verify a capability\nbytes32 capabilityHash = keccak256("text-generation");\nidentityRegistry.verifyCapability(agentId, capabilityHash, zkProofBytes);\n'})}),"\n",(0,d.jsxs)(t.admonition,{title:"SDK Integration",type:"info",children:[(0,d.jsxs)(t.p,{children:["The TypeScript SDK provides a higher-level interface via ",(0,d.jsx)(t.code,{children:"IdentityClient"})," and ",(0,d.jsx)(t.code,{children:"RegistrationBuilder"}),":"]}),(0,d.jsx)(t.pre,{children:(0,d.jsx)(t.code,{className:"language-typescript",children:"import { TALClient } from '@tokamak/tal-sdk';\n\nconst client = new TALClient({ ... });\nconst agentId = await client.identity.register(\"ipfs://QmYourAgentMetadata...\");\n"})}),(0,d.jsxs)(t.p,{children:["See the ",(0,d.jsx)(t.a,{href:"/sdk/overview",children:"SDK documentation"})," for details."]})]}),"\n",(0,d.jsx)(t.h2,{id:"related-pages",children:"Related Pages"}),"\n",(0,d.jsxs)(t.ul,{children:["\n",(0,d.jsxs)(t.li,{children:[(0,d.jsx)(t.a,{href:"./reputation-registry",children:"Reputation Registry"})," -- feedback and reputation scoring for registered agents"]}),"\n",(0,d.jsxs)(t.li,{children:[(0,d.jsx)(t.a,{href:"./validation-registry",children:"Validation Registry"})," -- task validation for agent outputs"]}),"\n",(0,d.jsxs)(t.li,{children:[(0,d.jsx)(t.a,{href:"./task-fee-escrow",children:"Task Fee Escrow"})," -- payment escrow referencing agent identity"]}),"\n",(0,d.jsxs)(t.li,{children:[(0,d.jsx)(t.a,{href:"./deployment-and-security",children:"Deployment & Security"})," -- proxy patterns, roles, and deployed addresses"]}),"\n"]})]})}function o(e={}){const{wrapper:t}={...(0,r.R)(),...e.components};return t?(0,d.jsx)(t,{...e,children:(0,d.jsx)(h,{...e})}):h(e)}},8453(e,t,n){n.d(t,{R:()=>s,x:()=>c});var i=n(6540);const d={},r=i.createContext(d);function s(e){const t=i.useContext(r);return i.useMemo(function(){return"function"==typeof e?e(t):{...t,...e}},[t,e])}function c(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(d):e.components||d:s(e.components),i.createElement(r.Provider,{value:t},e.children)}}}]);