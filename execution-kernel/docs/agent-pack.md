# Agent Pack

Agent Pack is a portable bundle format for distributing verifiable agents. It provides a standardized way for third-party developers to package their agents with all the cryptographic commitments needed for integrators and marketplaces to verify authenticity without touching kernel internals.

## Introduction

When you build an agent for the Execution Kernel, the compilation process produces several cryptographic artifacts that bind your code to an on-chain identity. The Agent Pack format captures these artifacts along with metadata about your agent, creating a self-contained bundle that anyone can verify.

An Agent Pack manifest answers the question: "Is this agent binary authentic, and does it match what was registered on-chain?" Integrators can perform this verification entirely offline, without needing access to the original build environment or trusting the agent developer.

## The Cryptographic Chain

The security of Agent Pack rests on a chain of cryptographic commitments that link your source code to the on-chain verifier:

```
Agent Source Code
       │
       ▼ (build.rs computes SHA-256)
agent_code_hash ─────────────────────────┐
       │                                 │
       ▼ (RISC Zero compilation)         │
    ELF Binary                           │
       │                                 │
       ├──▶ elf_sha256 (SHA-256)         │
       │                                 │
       ▼ (RISC Zero hash)                │
   image_id ─────────────────────────────┤
       │                                 │
       ▼ (deployed on-chain)             │
 Verifier Contract ◀─────────────────────┘
```

Each step in this chain is deterministic. Given the same source code and build environment, you will always get the same `agent_code_hash`, the same ELF binary, and the same `image_id`. This reproducibility is what makes verification possible.

The `image_id` is the critical link to on-chain verification. When a proof is submitted to the verifier contract, the contract checks that the proof was generated by a program with a specific `image_id`. By including the `image_id` in the manifest, integrators can verify that a given agent binary corresponds to what's registered on-chain.

## Manifest Contents

The manifest is a JSON file containing all metadata and commitments needed for verification. Here's what each field represents:

### Identity Fields

- **format_version**: Always "1" for this version of the format
- **agent_name**: Human-readable name (e.g., "yield-agent")
- **agent_version**: Semantic version (e.g., "0.1.0")
- **agent_id**: 32-byte identifier registered in the kernel

### Protocol Compatibility

- **protocol_version**: The kernel protocol version this agent targets
- **kernel_version**: The kernel version used during compilation
- **risc0_version**: RISC Zero zkVM version (e.g., "3.0.4")
- **rust_toolchain**: Rust compiler version (e.g., "1.75.0")

### Cryptographic Commitments

- **agent_code_hash**: SHA-256 of the agent code, computed at build time by `build.rs`
- **image_id**: RISC Zero IMAGE_ID computed from the ELF binary

### Artifacts

- **artifacts.elf_path**: Path to the ELF binary relative to the manifest
- **artifacts.elf_sha256**: SHA-256 of the ELF binary for integrity verification

### Build Information

- **build.cargo_lock_sha256**: SHA-256 of Cargo.lock for dependency pinning
- **build.build_command**: Exact command to reproduce the build
- **build.reproducible**: Whether reproducible builds are enabled (using Docker)

### Documentation

- **inputs**: Human-readable description of the expected input format
- **actions_profile**: Description of what actions the agent produces

### Deployment (Optional)

- **networks**: Map of network names to deployment addresses
- **git**: Repository URL and commit hash for source traceability
- **notes**: Any additional information

## Producing an Agent Pack

### Step 1: Initialize the Manifest

Start by creating a manifest template with your agent's identity:

```bash
agent-pack init \
  --name my-yield-agent \
  --version 1.0.0 \
  --agent-id 0x0000000000000000000000000000000000000000000000000000000000000042
```

This creates `./dist/agent-pack.json` with placeholder values for computed fields.

### Step 2: Build Your Agent

Build your agent using the RISC Zero toolchain. For reproducible builds, use Docker:

```bash
RISC0_USE_DOCKER=1 cargo build --release -p risc0-methods
```

The ELF binary will be in `target/riscv-guest/riscv32im-risc0-zkvm-elf/release/`.

### Step 3: Compute Hashes

Use the `compute` command to populate the cryptographic fields:

```bash
agent-pack compute \
  --elf target/riscv-guest/riscv32im-risc0-zkvm-elf/release/zkvm-guest \
  --out dist/agent-pack.json \
  --cargo-lock Cargo.lock
```

This computes and updates:
- `artifacts.elf_sha256` from the ELF binary
- `image_id` from the ELF binary (requires `--features risc0`)
- `build.cargo_lock_sha256` from your lock file

### Step 4: Fill in Documentation

Edit the manifest to add:
- A description of your input format in `inputs`
- What actions your agent produces in `actions_profile`
- Network deployment addresses in `networks`
- Git repository information in `git`

### Step 5: Verify the Manifest

Run verification to ensure everything is correct:

```bash
agent-pack verify --manifest dist/agent-pack.json
```

## Verifying an Agent Pack

Integrators receive an Agent Pack (manifest + ELF binary) and want to verify its authenticity.

### Basic Verification

Structure-only verification checks that the manifest is well-formed:

```bash
agent-pack verify --manifest agent-pack.json --structure-only
```

This validates:
- All required fields are present
- Hex strings have correct format (0x prefix, 64 hex chars)
- Version strings are valid semver
- No placeholder values remain

### Full Verification

Full verification also checks the ELF binary:

```bash
agent-pack verify --manifest agent-pack.json --base-dir ./artifacts
```

This additionally:
- Verifies the ELF file exists
- Recomputes `elf_sha256` and compares to manifest
- Recomputes `image_id` and compares to manifest (if built with `--features risc0`)

### On-Chain Verification

After offline verification passes, compare the `image_id` from the manifest against the value registered in the on-chain verifier contract. If they match, the agent binary is authentic.

## Reproducible Builds

For maximum trust, use reproducible builds with Docker:

```bash
RISC0_USE_DOCKER=1 cargo build --release -p risc0-methods
```

This ensures that anyone with the same source code and Cargo.lock can produce an identical ELF binary, which means an identical `image_id`. The `build.reproducible` field indicates whether this was used.

When verifying an agent with `reproducible: true`, integrators can:
1. Check out the source at the specified git commit
2. Run the build command
3. Compare the resulting `elf_sha256` and `image_id` to the manifest

## Publishing an Agent

The bundle workflow streamlines distribution by creating a self-contained directory that integrators can verify without any build tools. Use `agent-pack pack` to produce a distributable bundle from your built agent.

### Creating a Bundle

After building your agent and populating your manifest, create a bundle:

```bash
agent-pack pack \
  --manifest dist/agent-pack.json \
  --elf target/riscv-guest/riscv32im-risc0-zkvm-elf/release/zkvm-guest \
  --out my-agent-bundle \
  --cargo-lock Cargo.lock
```

This produces a directory containing:

```
my-agent-bundle/
├── agent-pack.json      # Manifest with computed hashes
└── artifacts/
    └── zkvm-guest       # Copy of the ELF binary
```

The manifest's `artifacts.elf_path` is automatically set to a relative path (`artifacts/zkvm-guest`), making the bundle portable.

### What Gets Computed

The `pack` command recomputes certain fields to ensure the manifest matches the actual binary:

- **elf_sha256**: SHA-256 of the ELF binary
- **cargo_lock_sha256**: SHA-256 of Cargo.lock (if provided)
- **image_id**: RISC Zero IMAGE_ID (requires `--features risc0`)

Fields that are not recomputed include `agent_code_hash` (derived from source at build time) and metadata fields like `inputs` and `actions_profile`. These must be populated in your input manifest before packing.

### Verifying a Bundle

Recipients verify the bundle using the same tool:

```bash
agent-pack verify \
  --manifest my-agent-bundle/agent-pack.json \
  --base-dir my-agent-bundle
```

This checks that the ELF binary matches the declared hash. If built with `--features risc0`, it also verifies the IMAGE_ID matches.

### Distribution

Ship the entire bundle directory. Integrators receive:

1. The manifest with all cryptographic commitments
2. The exact ELF binary you built
3. Everything needed to verify authenticity offline

They can then compare the `image_id` against on-chain registrations to confirm the agent is legitimate.

### What Changes Each Hash

Understanding what triggers hash changes helps with versioning:

| Change | agent_code_hash | elf_sha256 | image_id |
|--------|-----------------|------------|----------|
| Agent source code | Yes | Yes | Yes |
| SDK version | No | Yes | Yes |
| Rust toolchain | No | Yes | Yes |
| Cargo.lock dependencies | No | Yes | Yes |
| RISC Zero version | No | Yes | Yes |
| Manifest metadata only | No | No | No |

The `agent_code_hash` is the most stable identifier - it only changes when your agent's source files change. The `image_id` is the most comprehensive - any change to the build environment affects it.

## Marketplace Ingestion and On-Chain Verification

Offline verification with `agent-pack verify` confirms that a manifest is well-formed and that the ELF binary matches its declared hashes. However, this does not guarantee the agent is actually registered on-chain. A marketplace accepting agent submissions must take the additional step of querying the KernelExecutionVerifier contract.

The `verify-onchain` command bridges this gap. It reads the `agent_id` and `image_id` from the manifest, queries the contract registry, and confirms the values match.

### Usage

```bash
agent-pack verify-onchain \
  --manifest agent-pack.json \
  --rpc https://sepolia.infura.io/v3/YOUR_KEY \
  --verifier 0x9Ef5bAB590AFdE8036D57b89ccD2947D4E3b1EFA
```

Note: The `verify-onchain` command requires building with the `onchain` feature:

```bash
cargo build -p agent-pack --features onchain
```

### Exit Codes

The command returns structured exit codes for CI integration:

| Exit Code | Meaning |
|-----------|---------|
| 0 | Agent is registered and image_id matches |
| 1 | Error (RPC failure, invalid manifest, etc.) |
| 2 | Agent is registered but image_id differs |
| 3 | Agent is not registered (agent_id returns zero) |

### Marketplace Workflow

A complete verification workflow for marketplaces:

1. Receive submission (manifest + ELF bundle)
2. Run `agent-pack verify` for offline validation
3. Run `agent-pack verify-onchain` to confirm registration
4. Only accept if both pass

Example CI script:

```bash
#!/bin/bash
set -e

# Step 1: Offline verification
agent-pack verify --manifest submission/agent-pack.json --base-dir submission

# Step 2: On-chain verification
agent-pack verify-onchain \
  --manifest submission/agent-pack.json \
  --rpc "$RPC_URL" \
  --verifier 0x9Ef5bAB590AFdE8036D57b89ccD2947D4E3b1EFA

echo "Agent verified successfully!"
```

### Contract Interface

The `verify-onchain` command queries the `agentImageIds` mapping on the KernelExecutionVerifier contract:

```solidity
function agentImageIds(bytes32 agentId) external view returns (bytes32);
```

This mapping returns:
- The registered `image_id` if the agent is registered
- `bytes32(0)` if the agent is not registered

## CLI Reference

### `agent-pack init`

Creates a new manifest template.

```
USAGE:
    agent-pack init [OPTIONS] --name <NAME> --version <VERSION> --agent-id <AGENT_ID>

OPTIONS:
    -n, --name <NAME>          Agent name
    -v, --version <VERSION>    Agent version (semver)
    -a, --agent-id <AGENT_ID>  32-byte agent ID (0x hex)
    -o, --out <PATH>           Output path [default: ./dist/agent-pack.json]
```

### `agent-pack compute`

Computes hashes from ELF binary and updates the manifest.

```
USAGE:
    agent-pack compute [OPTIONS] --elf <PATH>

OPTIONS:
    -e, --elf <PATH>           Path to ELF binary
    -o, --out <PATH>           Manifest path [default: ./dist/agent-pack.json]
        --cargo-lock <PATH>    Path to Cargo.lock for hash computation
```

Note: IMAGE_ID computation requires building with `--features risc0`.

### `agent-pack verify`

Verifies a manifest's integrity.

```
USAGE:
    agent-pack verify [OPTIONS]

OPTIONS:
    -m, --manifest <PATH>      Manifest path [default: ./dist/agent-pack.json]
    -b, --base-dir <PATH>      Base directory for resolving artifact paths
        --structure-only       Only verify manifest structure, skip file verification
```

### `agent-pack pack`

Creates a distributable bundle from a manifest and ELF binary.

```
USAGE:
    agent-pack pack --manifest <PATH> --elf <PATH> --out <DIR> [OPTIONS]

OPTIONS:
    -m, --manifest <PATH>      Path to input manifest
    -e, --elf <PATH>           Path to built ELF binary
    -o, --out <DIR>            Output directory for bundle
        --cargo-lock <PATH>    Path to Cargo.lock for hash computation
        --copy-elf             Copy ELF to bundle [default: true]
        --force                Overwrite existing output directory
```

The bundle is immediately verifiable:

```bash
agent-pack verify --manifest <out>/agent-pack.json --base-dir <out>
```

### `agent-pack verify-onchain`

Verifies agent registration against the on-chain KernelExecutionVerifier contract.

```
USAGE:
    agent-pack verify-onchain --manifest <PATH> --rpc <URL> --verifier <ADDRESS>

OPTIONS:
    -m, --manifest <PATH>      Path to manifest file
        --rpc <URL>            RPC endpoint URL
        --verifier <ADDRESS>   KernelExecutionVerifier contract address
        --timeout-ms <MS>      RPC timeout in milliseconds [default: 30000]
```

Note: Requires building with `--features onchain`.

Exit codes:
- `0`: Match (image_id matches on-chain)
- `1`: Error (RPC failure, parse error, etc.)
- `2`: Mismatch (image_id differs from on-chain)
- `3`: Not registered (agent_id returns zero)

## JSON Schema

A JSON Schema for validating manifests is available at `docs/agent-pack.schema.json`. Use it with your favorite JSON validator:

```bash
# Using ajv-cli
npx ajv validate -s docs/agent-pack.schema.json -d dist/agent-pack.json
```

## Example Manifest

See `dist/agent-pack.example.json` for a complete example using the yield agent.
